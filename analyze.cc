
#include <iostream>
#include <stdlib.h>
#include <math.h> 
#include<limits>
#include <fstream>
#include <unistd.h>
#include <getopt.h>
#include <ctime>
#include <numeric>      // std::iota
#include <algorithm>    // std::sort, std::stable_sort
#include <regex>
#include<omp.h>
#include <sstream>
// -------------------- OpenMesh
#include <OpenMesh/Core/System/omstream.hh>
#include <OpenMesh/Core/IO/MeshIO.hh>
#include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>
#include <OpenMesh/Core/Utils/PropertyManager.hh>
#include <OpenMesh/Apps/Assembly/topology.hh>
#include <OpenMesh/Apps/Assembly/geometry.hh>
#include <OpenMesh/Apps/Assembly/energy.hh>
#include <OpenMesh/Apps/Assembly/monte_carlo.hh>
#include <OpenMesh/Apps/Assembly/monte_carlo_wall.hh>
#include <OpenMesh/Apps/Assembly/excluders.hh>
#include <OpenMesh/Apps/Assembly/custom_mesh_props.hh>
#include <OpenMesh/Apps/Assembly/IO.hh>
#include <OpenMesh/Apps/Assembly/run.hh>
#include <OpenMesh/Apps/Assembly/random.hh>
#include <OpenMesh/Apps/Assembly/subset_division.hh>
#include <OpenMesh/Apps/Assembly/analyze.hh>
#include <OpenMesh/Tools/SmartTagger/SmartTaggerT.hh>



/* get a column value at specified timestep from the data_log.dat file */
std::string get_value_at_t(std::string logfile, long timestep, int column){
	std::ifstream datfile(logfile);
	std::string line;
	std::string tret;
	std::getline(datfile, line); //skip first line
	while (std::getline(datfile, line))
	{
	    std::istringstream iss(line);

	    std::string t;
	    std::string col;

	    iss>>t;
	    //std::cout<<"read t "<<t<<std::endl;
	    if (std::stol(t)==timestep){
	    	for (int c=0; c<column; c++){
	    		iss>>col;
	    	}
	    	datfile.close();
	    	//std::cout<<"read t "<<t<<" col "<<col<<std::endl;
	    	return col;
	    }
	    /*while(iss>>t){
	    	std::cout<<a<<" ";
	    }
	    std::cout<<std::endl;
	    */
	}

	datfile.close();

	std::string col;
	return col;
}


void print_mesh_stripped(MyMesh & mesh){
	auto edge_props = OpenMesh::HProp<int>(mesh, "edge_type");
	auto face_props = OpenMesh::FProp<int>(mesh, "face_type");
	int edge_type;
	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it != mesh.faces_end(); ++f_it){
		std::cout<<"face "<< *f_it<<" face_type "<<face_props[*f_it];
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			edge_type = edge_props[*fh_it];	
			//std::cout<<"e_b"<< e_b<<" theta0 "<<theta0;
			std::cout<<" edge_type "<<edge_type;//<<std::endl;
		}	
	std::cout<<std::endl; 
}
return;
}

//assumes a full mesh input
void quench_mesh(MyMesh & mesh){
	std::mt19937 eng(13*73 + 17);
	auto mesh_props = OpenMesh::MProp<MeshProp>(mesh, "mesh_props");
	double quench_factor=1+5.e-3;
	for (long t=0; t<1000; t++){
		for (int n=0; n<(int)mesh.n_vertices(); n++){
			attempt_move(mesh, eng);
		}
		(*mesh_props).kT/=quench_factor;
		(*mesh_props).d_max/=sqrt(quench_factor);
	}

	//from here on do athermal move only, but still decrease d_max
	for (long t=0; t<1000; t++){
		for (int n=0; n<(int)mesh.n_vertices(); n++){
			attempt_move_athermal(mesh, eng);
		}

		(*mesh_props).d_max/=sqrt(quench_factor);
	}	
}


//needs full mesh for the energies
int dump_lammps_snapshot_with_energies(MyMesh mesh, std::string outfile_path, long timestep){
	auto edge_props = OpenMesh::HProp<HalfedgeProp>(mesh, "edge_props");

   	std::ofstream os( outfile_path+"lammps_"+std::to_string(timestep)+".dat" );
   	std::ofstream os_post_quench( outfile_path+"lammps_post_quench_"+std::to_string(timestep)+".dat" );   	
   	std::ofstream stretch_energy_os( outfile_path+"stretch_energy_"+std::to_string(timestep)+".dat" ); 
   	std::ofstream bend_energy_os( outfile_path+"bend_energy_"+std::to_string(timestep)+".dat" );   
    std::ofstream elastic_energy_os( outfile_path+"bond_energy_"+std::to_string(timestep)+".dat" );   		   	  	

	os.precision(6);	
	os.setf(std::ios::fixed);
	os.setf(std::ios::showpoint);

	os_post_quench.precision(6);	
	os_post_quench.setf(std::ios::fixed);
	os_post_quench.setf(std::ios::showpoint);	

	stretch_energy_os.precision(6);	
	stretch_energy_os.setf(std::ios::fixed);
	stretch_energy_os.setf(std::ios::showpoint);

	bend_energy_os.precision(6);	
	bend_energy_os.setf(std::ios::fixed);
	bend_energy_os.setf(std::ios::showpoint);	

	elastic_energy_os.precision(6);	
	elastic_energy_os.setf(std::ios::fixed);
	elastic_energy_os.setf(std::ios::showpoint);	


	MyMesh::Point com = MyMesh::Point(0,0,0);
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		com+=mesh.point(*v) / mesh.n_vertices();
	}
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		mesh.set_point(*v, mesh.point(*v) - com );
	}	

	os<<"LAMMPSDescription-Generated by btyukodi"<<std::endl;
	os<<std::endl;
	os<<mesh.n_vertices()<<" atoms"<<std::endl;
	os<<mesh.n_edges()<<" bonds"<<std::endl;
	os<<std::endl;
	os<<"1 atom types"<<std::endl;
	os<<"2 bond types"<<std::endl;
	os<<std::endl;
	os<<"  -12.000    12.000 xlo xhi"<<std::endl;
	os<<"  -12.000    12.000 ylo yhi"<<std::endl;
	os<<"  -12.000    12.000 zlo zhi"<<std::endl;		
	os<<std::endl;
	os<<"Atoms"<<std::endl;
	os<<std::endl;
	int atom_type=1;
	MyMesh::Point p;	
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		os<<(*v).idx()+1<<" "<<atom_type<<" "<<p[0]<<" "<<p[1]<<" "<<p[2]<<std::endl;
		//std::cout<<"valence "<<mesh.valence(*v)<<std::endl;
	}


	//QUENCH HERE
	quench_mesh(mesh);


	os_post_quench<<"LAMMPSDescription-Generated by btyukodi"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<mesh.n_vertices()<<" atoms"<<std::endl;
	os_post_quench<<mesh.n_edges()<<" bonds"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<"1 atom types"<<std::endl;
	os_post_quench<<"2 bond types"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<"  -12.000    12.000 xlo xhi"<<std::endl;
	os_post_quench<<"  -12.000    12.000 ylo yhi"<<std::endl;
	os_post_quench<<"  -12.000    12.000 zlo zhi"<<std::endl;		
	os_post_quench<<std::endl;
	os_post_quench<<"Atoms"<<std::endl;
	os_post_quench<<std::endl;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		os_post_quench<<(*v).idx()+1<<" "<<atom_type<<" "<<p[0]<<" "<<p[1]<<" "<<p[2]<<std::endl;
		//std::cout<<"valence "<<mesh.valence(*v)<<std::endl;
	}

	os<<std::endl;
	os<<"Bonds"<<std::endl;
	os<<std::endl;

	os_post_quench<<std::endl;
	os_post_quench<<"Bonds"<<std::endl;
	os_post_quench<<std::endl;	
	//int bond_type=1;
	//for now, use bond_type to color boundary edges to follow cracks
	int bond_type;
	MyMesh::HalfedgeHandle hedge;
	MyMesh::VertexHandle v1, v2;

	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		hedge = mesh.halfedge_handle(*e_it, 0);
		v1 = mesh.from_vertex_handle(hedge);
		v2 = mesh.to_vertex_handle(hedge);
		if (mesh.is_boundary(*e_it)){
			bond_type=2;
		}
		else{
			bond_type=1;
		}
		os<<(*e_it).idx()+1<<" "<< bond_type <<" "<<v1.idx()+1<<" "<<v2.idx()+1<<std::endl;
		os_post_quench<<(*e_it).idx()+1<<" "<< bond_type <<" "<<v1.idx()+1<<" "<<v2.idx()+1<<std::endl;		
		stretch_energy_os<<(*e_it).idx()+1<<" "<<edge_stretch_energy(mesh, *e_it, edge_props)<<std::endl;
		bend_energy_os<<(*e_it).idx()+1<<" "<<edge_bending_energy(mesh, *e_it, edge_props)<<std::endl;
		elastic_energy_os<<(*e_it).idx()+1<<" "<<edge_stretch_energy(mesh, *e_it, edge_props) + edge_bending_energy(mesh, *e_it, edge_props)<<std::endl;
	}

	os.close();
	os_post_quench.close();
	stretch_energy_os.close();	
	bend_energy_os.close();
	elastic_energy_os.close();
	return 1;
}


//needs full mesh for the energies
int dump_lammps_snapshot_with_average_energies(MyMesh mesh, std::string outfile_path, long timestep, Wall & wall){
	std::mt19937 eng(13*73 + 17);
	auto edge_props = OpenMesh::HProp<HalfedgeProp>(mesh, "edge_props");

   	std::ofstream os( outfile_path+"lammps_"+std::to_string(timestep)+".dat" );
   	std::ofstream os_post_quench( outfile_path+"lammps_post_quench_"+std::to_string(timestep)+".dat" );   	
   	std::ofstream stretch_energy_os( outfile_path+"stretch_energy_"+std::to_string(timestep)+".dat" ); 
   	std::ofstream bend_energy_os( outfile_path+"bend_energy_"+std::to_string(timestep)+".dat" );   
    std::ofstream elastic_energy_os( outfile_path+"bond_energy_"+std::to_string(timestep)+".dat" );   		   	  	

	os.precision(6);	
	os.setf(std::ios::fixed);
	os.setf(std::ios::showpoint);

	os_post_quench.precision(6);	
	os_post_quench.setf(std::ios::fixed);
	os_post_quench.setf(std::ios::showpoint);	

	stretch_energy_os.precision(6);	
	stretch_energy_os.setf(std::ios::fixed);
	stretch_energy_os.setf(std::ios::showpoint);

	bend_energy_os.precision(6);	
	bend_energy_os.setf(std::ios::fixed);
	bend_energy_os.setf(std::ios::showpoint);	

	elastic_energy_os.precision(6);	
	elastic_energy_os.setf(std::ios::fixed);
	elastic_energy_os.setf(std::ios::showpoint);	


	MyMesh::Point com = MyMesh::Point(0,0,0);
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		com+=mesh.point(*v) / mesh.n_vertices();
	}
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		mesh.set_point(*v, mesh.point(*v) - com );
	}	

	os<<"LAMMPSDescription-Generated by btyukodi"<<std::endl;
	os<<std::endl;
	os<<mesh.n_vertices()<<" atoms"<<std::endl;
	os<<mesh.n_edges()<<" bonds"<<std::endl;
	os<<std::endl;
	os<<"2 atom types"<<std::endl;
	os<<"2 bond types"<<std::endl;
	os<<std::endl;
	os<<"  -12.000    12.000 xlo xhi"<<std::endl;
	os<<"  -12.000    12.000 ylo yhi"<<std::endl;
	os<<"  -12.000    12.000 zlo zhi"<<std::endl;		
	os<<std::endl;
	os<<"Atoms"<<std::endl;
	os<<std::endl;
	int atom_type=1;
	MyMesh::Point p;	
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		if (mesh.is_boundary(*v)){
			atom_type=2;
		}
		else{
			atom_type=1;
		}		
		os<<(*v).idx()+1<<" "<<atom_type<<" "<<p[0]<<" "<<p[1]<<" "<<p[2]<<std::endl;
		//std::cout<<"valence "<<mesh.valence(*v)<<std::endl;
	}



	std::vector<double> avg_edge_stretch_energy(mesh.n_edges(), 0.0);
	std::vector<double> avg_edge_bending_energy(mesh.n_edges(), 0.0);	
	long tmax = 1000;


	for (long t=0; t<tmax; t++){
		for (int n=0; n<(int)mesh.n_vertices(); n++){
			//need the wall here
			attempt_move_wall(mesh, eng, wall);
		}

		for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
			avg_edge_stretch_energy[(*e_it).idx()]+=edge_stretch_energy(mesh, *e_it, edge_props)/tmax;
			avg_edge_bending_energy[(*e_it).idx()]+=edge_bending_energy(mesh, *e_it, edge_props)/tmax;
		}

	}


	os_post_quench<<"LAMMPSDescription-Generated by btyukodi"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<mesh.n_vertices()<<" atoms"<<std::endl;
	os_post_quench<<mesh.n_edges()<<" bonds"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<"2 atom types"<<std::endl;
	os_post_quench<<"2 bond types"<<std::endl;
	os_post_quench<<std::endl;
	os_post_quench<<"  -12.000    12.000 xlo xhi"<<std::endl;
	os_post_quench<<"  -12.000    12.000 ylo yhi"<<std::endl;
	os_post_quench<<"  -12.000    12.000 zlo zhi"<<std::endl;		
	os_post_quench<<std::endl;
	os_post_quench<<"Atoms"<<std::endl;
	os_post_quench<<std::endl;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		if (mesh.is_boundary(*v)){
			atom_type=2;
		}
		else{
			atom_type=1;
		}
		os_post_quench<<(*v).idx()+1<<" "<<atom_type<<" "<<p[0]<<" "<<p[1]<<" "<<p[2]<<std::endl;
		//std::cout<<"valence "<<mesh.valence(*v)<<std::endl;
	}

	os<<std::endl;
	os<<"Bonds"<<std::endl;
	os<<std::endl;

	os_post_quench<<std::endl;
	os_post_quench<<"Bonds"<<std::endl;
	os_post_quench<<std::endl;	
	//int bond_type=1;
	//for now, use bond_type to color boundary edges to follow cracks
	int bond_type;
	MyMesh::HalfedgeHandle hedge;
	MyMesh::VertexHandle v1, v2;

	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		hedge = mesh.halfedge_handle(*e_it, 0);
		v1 = mesh.from_vertex_handle(hedge);
		v2 = mesh.to_vertex_handle(hedge);
		if (mesh.is_boundary(*e_it)){
			bond_type=2;
		}
		else{
			bond_type=1;
		}
		os<<(*e_it).idx()+1<<" "<< bond_type <<" "<<v1.idx()+1<<" "<<v2.idx()+1<<std::endl;
		os_post_quench<<(*e_it).idx()+1<<" "<< bond_type <<" "<<v1.idx()+1<<" "<<v2.idx()+1<<std::endl;		
		stretch_energy_os<<(*e_it).idx()+1<<" "<<avg_edge_stretch_energy[(*e_it).idx()]<<std::endl;
		bend_energy_os<<(*e_it).idx()+1<<" "<<avg_edge_bending_energy[(*e_it).idx()]<<std::endl;
		elastic_energy_os<<(*e_it).idx()+1<<" "<<avg_edge_stretch_energy[(*e_it).idx()] + avg_edge_bending_energy[(*e_it).idx()]<<std::endl;
	}

	os.close();
	os_post_quench.close();
	stretch_energy_os.close();	
	bend_energy_os.close();
	elastic_energy_os.close();
	return 1;
}

void count_vertices(MyMesh & mesh){
	std::cout<<"analyze.cc --> count_vertices()"<<std::endl;	
	std::cout<<mesh.n_vertices()<<std::endl;
}

//count vertices of given valence
int count_vertices(MyMesh & mesh, int valence, bool non_boundary_only=false){
	int nv=0;
	for (MyMesh::VertexIter vit = mesh.vertices_sbegin(); vit != mesh.vertices_end(); ++vit){
		if (mesh.is_boundary(*vit) && non_boundary_only){
			continue;
		}
		if(mesh.valence(*vit)==valence ){
			nv++;
		}
    }
    return nv; 
}



//go over each vertex and print its valence and whether it's a boundary vertex
void loop_over_vertices(MyMesh & mesh){
	std::cout<<"analyze.cc --> loop_over_vertices()"<<std::endl;
	for (MyMesh::VertexIter vit = mesh.vertices_sbegin(); vit != mesh.vertices_end(); ++vit){
		std::cout<<*vit<<" "<<mesh.valence(*vit)<<" boundary?"<< mesh.is_boundary(*vit)<<std::endl;
    }  
}

void loop_over_rim(MyMesh & mesh){
	std::cout<<"analyze.cc --> loop_over_rim()"<<std::endl;
	MyMesh::HalfedgeHandle he, he_init, he_face;
	//find a halfedge that's on the boundary

	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		if (mesh.is_boundary(*hit)){
			he = *hit;
			break;
		}
    }  

    //now he is a boundary halfedge. I can start from it and go around the rim
    he_init = he;
    //this should be a while loop but I use for instead to avoid the danger of infinite loops
    for (int i=0; i<100000; i++){
    	he = mesh.next_halfedge_handle(he);
    	//he_face is the non-boundary halfedge that belongs to the face
    	he_face = mesh.opposite_halfedge_handle(he);
    	std::cout<<"halfedge "<<he_face<<std::endl;
    	if (he==he_init){
    		break;
    	}
    }
}

//print the full face and edge types
void print_snapshot(MyMesh & mesh){
	/*
	this function print_mesh() is in IO.cc; 
	Huang, check it out because it gives you a good idea of 
	1) how you can access face and edge types via the OpenMesh::HProp/FProp property managers; the structure of these properties is in cusom_mesh_props.hh
	2) how to use circulators: first iterate over faces and for each face iterate over the adjacent halfedges
	*/
	print_mesh(mesh);
}

//Huang, you would add here all your data process functions
//also, you can add a second argument "long timestep" to all functions so that you can save the processed data as you wish, in timestep-named files
//you can also add a file stream as an argument if you want to add all processed stuff in the same file
void analyze_snapshot(MyMesh & mesh, std::string outfile_path, long timestep){
	/*count_vertices(mesh);
	loop_over_vertices(mesh);
	loop_over_rim(mesh);
	print_snapshot(mesh);*/
	dump_lammps_snapshot_with_energies(mesh, outfile_path, timestep);


}

void analyze_snapshot_wall(MyMesh & mesh, std::string outfile_path, long timestep, Wall & wall){
	/*count_vertices(mesh);
	loop_over_vertices(mesh);
	loop_over_rim(mesh);
	print_snapshot(mesh);*/
	//dump_lammps_snapshot_with_energies(mesh, outfile_path, timestep);
	dump_lammps_snapshot_with_average_energies(mesh, outfile_path, timestep, wall);

}

//this function just calls analyze_snapshot for each snapshot specified in the input_file.json
void analyze_all(std::string input_file){

	MyMesh mesh;	
	//add parameters to init_mesh; if init_config provided, init_from_om too
    RunParameters rp;	
    read_set_run_params(rp, input_file); 
    std::string om_filename = rp.data_folder+"snapshots.om";
    std::string logfile = rp.data_folder+"data_log.dat";
    std::vector<long long> byte_positions;
    std::vector<long> timesteps;
    long long opos;
	Wall wall(rp.wall_hardness, 0, 0, rp.wall_amplitude);
	double z1, z2;

    //------- do a first reading round just to get the structure positions; these could have been read from the log file too ----------------------
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
 	//alernatingly read a timestep (long) and a mesh (.om) objects
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh_stripped;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh_stripped, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh_stripped, "edge_type");	
	opos = omfile.tellg();
	while (omfile >> timestep){

   		
   		OpenMesh::IO::read_mesh(mesh_stripped, omfile, _ext, ropt);

   		timesteps.push_back(timestep);
   		byte_positions.push_back(opos);
		std::cout<<"timestep "<<timestep<<" byte "<<opos<<" sizeof(long) "<<sizeof(long)<<std::endl;   
		opos = omfile.tellg();		
	}
	omfile.close();

	//-----------------------------------------------------------------------------------------------------------------------------------

	system(("mkdir -p "+rp.data_folder+"/energy_snapshots/").c_str()); 
	long long byte_pos;
	//=============== now start the actual processing ===========================
	for (int i=0; i<byte_positions.size(); i+=1){
		byte_pos = byte_positions[i];
		timestep = timesteps[i];
		std::cout<<"==============================================="<<std::endl;
		std::cout<<" processing snapshot of timestep "<<timestep<<" at byte "<<byte_pos<<std::endl;
		std::cout<<"==============================================="<<std::endl;

		mesh.request_face_status();
	  	mesh.request_edge_status();
	  	mesh.request_vertex_status();    
	  	mesh.request_halfedge_status();
		mesh.request_face_normals();
		init_mesh_from_om(mesh, om_filename,  byte_pos, input_file);
		//std::cout<<"Overlap "<<check_full_overlap(mesh)<<std::endl;
		/*
		analyze_snapshot(mesh, rp.data_folder+"/energy_snapshots/", timestep);
		*/

		//****** wall analysis *******************//
		//std::cout<<"read "<<get_value_at_t(logfile, timestep, 14)<<std::endl;
		z1 = std::stod(get_value_at_t(logfile, timestep, 27));
		z2 = std::stod(get_value_at_t(logfile, timestep, 28));		
		wall.z_position_1=z1;
		wall.z_position_2=z2;
		std::cout<<"z1 "<<z1<<" z2 "<<z2<<std::endl;
		analyze_snapshot_wall(mesh, rp.data_folder+"/energy_snapshots/", timestep, wall);	
		//********* wall analysis end ************//
	}
	//=============== processing done ========================================

}


std::vector<int> count_number_of_rims(MyMesh & mesh){
	std::vector<int> rim_lengths;

	//get all boundary edges
	std::vector<MyMesh::EdgeHandle> boundary_edges;
	for (MyMesh::EdgeIter eit = mesh.edges_sbegin(); eit != mesh.edges_end(); ++eit){
		if (mesh.is_boundary(*eit)){
			boundary_edges.push_back(*eit);
		}
    } 

    OpenMesh::SmartTaggerET< MyMesh > tagger(mesh);
	// Reset tagged flag on all edges
	tagger.untag_all();

	MyMesh::EdgeHandle b_edge;
	MyMesh::HalfedgeHandle hedge1, hedge2, hedge, hedge_init;
	bool all_visited;
	int nrims=0;
	int l_rim;
	//should be a while loop, using for to avoid the slightest chance of infinite loops
	for (int i=0; i<10000; i++){
		//find an untagged (i.e. unvisited) boundary edge to start from
		all_visited = true;
		for (auto & edge: boundary_edges){
			if(!tagger.get_tag(edge)){
				b_edge = edge;
				all_visited=false;
				break;
			}
		}

		//all rims are visited and counted
		if (all_visited){
			break;
		}

		hedge1 = mesh.halfedge_handle(b_edge, 0);
		hedge2 = mesh.halfedge_handle(b_edge, 1);
		if (mesh.is_boundary(hedge1)){
			hedge = hedge1;
		}
		else{
			hedge = hedge2;
		}
		//again, should be a while loop
		l_rim=0;
		hedge_init = hedge;
		for (int j=0; j<1000000; j++){
			l_rim++;
			tagger.set_tag(mesh.edge_handle(hedge));
			hedge = mesh.next_halfedge_handle(hedge);
			//break out when circled the full rim
			if (hedge==hedge_init){
				nrims++;
				//std::cout<<" l_rim "<<l_rim<<std::endl;
				rim_lengths.push_back(l_rim);
				break;
			}
		}

	}

    return rim_lengths;
}


//count number of subunits on the circumference. Only works if number of rims>=2 and assumes no defects and cylindrical/hexagonal packing
//also assumes that the negative curvature is perpendicular to the 0-type edge
std::tuple< std::vector<int>, std::vector<bool> >  count_Nperim(MyMesh & mesh){
	int etype=0;
	auto edge_type_prop = OpenMesh::HProp<int>(mesh, "edge_type");
	//should count all closed circumferences to detect mistakes/defects
	//find all edges with type-0 halfedges
	//go around all type-0 halfedges and tag all
	OpenMesh::SmartTaggerET< MyMesh > tagger(mesh);
	tagger.untag_all();

	std::vector<MyMesh::EdgeHandle> type_0_edges;
	MyMesh::EdgeHandle start_edge;
	MyMesh::HalfedgeHandle hedge1, hedge2, hedge, hedge_init;
	MyMesh::VertexHandle vertex_to;
	bool all_visited, next_halfedge_found, clear_cut;
	for (MyMesh::EdgeIter eit = mesh.edges_sbegin(); eit != mesh.edges_end(); ++eit){
			hedge1 = mesh.halfedge_handle(*eit, 0);
			hedge2 = mesh.halfedge_handle(*eit, 1);
			if (mesh.is_boundary(hedge1)){
				hedge=hedge2;
			}
			else{
				hedge=hedge1;
			}
			//std::cout<<"edge_type "<<edge_type_prop[hedge1]<<" "<<edge_type_prop[hedge2]<<std::endl;
			if( (edge_type_prop[hedge]==etype) ){
				type_0_edges.push_back(*eit);
			}
		
    } 

    //std::cout<<"no. of type0 edges "<<type_0_edges.size()<<std::endl;
    std::vector<int> Nperim_list;
    std::vector<bool> clear_cut_list;
    int Nperim;
	//should be a while loop, using for to avoid the slightest chance of infinite loops
	for (int i=0; i<10000; i++){
		all_visited = true;
		for (auto & edge: type_0_edges){
			if(!tagger.get_tag(edge)){
				start_edge = edge;
				all_visited=false;
				break;
			}
		}

		if (all_visited){
			//std::cout<<"all visited"<<std::endl;
			break;
		}

		hedge = mesh.halfedge_handle(start_edge, 0);
		if (mesh.is_boundary(hedge)){
			hedge = mesh.opposite_halfedge_handle(hedge);
		}
		hedge_init = hedge;
		Nperim=1;
		clear_cut = true;
		for (int j=0; j<1000000; j++){
			//if (tagger.get_tag(mesh.edge_handle(hedge))) {std::cout<<"shouldn't be tagged "<<j<<" "<<i<<" "<< hedge<<std::endl;}
			//std::cout<<"hedge "<<hedge<<" b?"<<mesh.is_boundary(hedge) <<" edge "<< mesh.edge_handle(hedge)<<std::endl;

			if (!mesh.is_boundary(mesh.edge_handle(hedge))){
				clear_cut=false;
			}

			tagger.set_tag(mesh.edge_handle(hedge));
			//circulator to find the next type 0 in the loop
			vertex_to = mesh.to_vertex_handle(hedge);

			next_halfedge_found = false;
			for (MyMesh::VertexOHalfedgeIter h_it = mesh.voh_iter(vertex_to); h_it.is_valid(); ++h_it){
				if ((edge_type_prop[*h_it]==etype) && (!mesh.is_boundary(*h_it)) && (mesh.to_vertex_handle(*h_it)!=mesh.from_vertex_handle(hedge))){
					/*if (hedge==*h_it){
						std::cout<<"WRONG"<<std::endl;
					}*/
					hedge = *h_it;
					next_halfedge_found=true;

					break;
				}
			}
			//can't find next halfedge of type0 because the loop cannot be closed
			if (!next_halfedge_found){
				//std::cout<<"open - i, j "<<i<<" "<<j<<std::endl;
				break;
			}

			//if loop has closed
			if (hedge==hedge_init){
				Nperim_list.push_back(Nperim);
				clear_cut_list.push_back(clear_cut);
				//std::cout<<"i, j "<<i<<" "<<j<<std::endl;
				break;
			}

			Nperim++;
		}

	}    
	//cancel if surface vertex is reached
	//otherwise measure the circumference
	//repeat until there are no untagged type-0 halfedges left
	/*for (auto & Np: Nperim_list){
		std::cout<<" Np "<<Np;
	}
	std::cout<<std::endl;
	for (auto cc: clear_cut_list){
		std::cout<<" cc "<<cc;
	}
	std::cout<<std::endl;*/	
	//return Nperim_list.size();

	return std::make_pair(Nperim_list, clear_cut_list);
}

//count type0, 1, 2 bonds
//return [n_type0, n_type1, n_type2, all_bonds]
std::vector<int> count_bonds(MyMesh & mesh){
	std::vector<int> bonds = {0, 0, 0, 0};
	int edge_type;
	auto edge_type_prop = OpenMesh::HProp<int>(mesh, "edge_type");
	MyMesh::HalfedgeHandle hedge1, hedge2;	
	for (MyMesh::EdgeIter eit = mesh.edges_sbegin(); eit != mesh.edges_end(); ++eit){
		hedge1 = mesh.halfedge_handle(*eit, 0);
		hedge2 = mesh.halfedge_handle(*eit, 1);
		//neither of them boundary
		if (!(mesh.is_boundary(hedge1)) && !(mesh.is_boundary(hedge2))){
			edge_type = edge_type_prop[hedge1];
			bonds[edge_type]++;
		}
	}
	bonds[3] = bonds[0]+bonds[1]+bonds[2];
	return bonds;
}

int count_boundary_edges(MyMesh & mesh){
	int n_boundary_edge=0;

	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		if (mesh.is_boundary(*e_it)){
			n_boundary_edge++;
		}
	}

	return n_boundary_edge;
}


int count_subunits_of_type(MyMesh & mesh, int face_type){
	auto face_props = OpenMesh::FProp<FaceProp>(mesh, "face_props");
	int nsub=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (face_props[*fit].face_type == face_type){
			nsub++;
		}

	}
	return nsub;
}

MyMesh::Point compute_COM(MyMesh & mesh){
	MyMesh::Point com = MyMesh::Point(0,0,0);
	MyMesh::Point p, dr;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		com+= p / mesh.n_vertices();
	}	
	return com;	
}

std::tuple<double, double> compute_asphericity(MyMesh & mesh){
	double dR2, R_avg, R2_avg;
	R_avg=0.0;
	R2_avg=0.0;

	MyMesh::Point com = MyMesh::Point(0,0,0);
	MyMesh::Point p, dr;
	MyMesh::Point e_avg = MyMesh::Point(0,0,0);
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		com+= p / mesh.n_vertices();
	}	

	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		p = mesh.point(*v);
		dr=(p-com);

		R_avg+=dr.norm() / mesh.n_vertices();
		R2_avg+=dr.sqrnorm() / mesh.n_vertices();

		dr[2]=0.0; //only work in the x-y plane
		e_avg+=dr/dr.norm(); 
	}	
		
	dR2 = sqrt(R2_avg - R_avg*R_avg)/R_avg;


	return std::make_pair(dR2, e_avg.norm()/mesh.n_vertices());
}



//use this when only topology-based analysis is needed
//works with simplified mesh, only simple edge types and face types
void topology_analyze_snapshot(MyMesh & mesh, long t, std::ostream& os){
/*
	auto edge_props = OpenMesh::HProp<int>(mesh, "edge_type");
	auto face_props = OpenMesh::FProp<int>(mesh, "face_type");
	int edge_type;
	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it != mesh.faces_end(); ++f_it){
		std::cout<<"--face "<< *f_it<<" face_type "<<face_props[*f_it];
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			edge_type = edge_props[*fh_it];	
			//std::cout<<"e_b"<< e_b<<" theta0 "<<theta0;
			std::cout<<" edge_type "<<edge_type;//<<std::endl;
		}	
	std::cout<<std::endl; 
	}
	return;
*/
	//loop_over_rim(mesh); //works on simplified mesh too
	std::vector<int> rim_lengths;
	rim_lengths = count_number_of_rims(mesh);
	std::vector<int> bonds = count_bonds(mesh);
	//std::cout<<"n_faces "<< mesh.n_faces()<<" nrims "<<rim_lengths.size()<<std::endl;
	os<<t<<" "<< mesh.n_faces()<<" "<<bonds[0]<<" "<<bonds[1]<<" "<<bonds[2]<<" "<<bonds[3]<<" "<<rim_lengths.size()<<" ";//<<std::endl;

	//std::cout<<std::endl;
	

	std::tuple< std::vector<int>, std::vector<bool> > Nperim_counts;
    std::vector<int> Nperim_list;
    std::vector<bool> clear_cut_list;	



	if (rim_lengths.size()>=2){		
		//std::cout<<"Nperim "<<count_Nperim(mesh)<<std::endl;
		//count_Nperim(mesh);
		Nperim_counts =count_Nperim(mesh);
	    Nperim_list = std::get<0>(Nperim_counts);
	    clear_cut_list = std::get<1>(Nperim_counts);
	    os<<Nperim_list.size()<<" ";
	    for (auto & Np: Nperim_list){
			os<<Np<<" ";
		}
		//std::cout<<std::endl;
		for (auto cc: clear_cut_list){
			os<<cc<<" ";
		}


	}
	else{
		os<<"-1"<<" ";
	}

	for (auto & l: rim_lengths){
		os<<l<<" ";
	}

	os<<std::endl;
}

//count coordination of vertices if they are not boundary vertex
//boundary vertices are considered to be part of cracks
int count_disclinations(MyMesh & mesh, int disclination_type){
	int n_disc=0;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if (!mesh.is_boundary(*v)){
			if (mesh.valence(*v)==disclination_type ){
				n_disc++;
			}
		}
	}
	return n_disc;
}


void defect_analyze_snapshot(MyMesh & mesh, long t, std::ostream& os){
	os<<t<<"\t"<<count_boundary_edges(mesh);
	for (int d=4; d<=8; d++){
		os<<"\t"<<count_disclinations(mesh, d);
	}
	os<<std::endl;

}


void topology_analyze_all(std::string om_filename){
	std::cout<<om_filename<<std::endl;
	//std::cout<<std::regex_replace(om_filename, std::regex("\/[^\/]\+$"), "/topology.dat")<<std::endl;
	std::cout<<std::regex_replace(om_filename, std::regex("/[^/]+$"), "/topology_defect.dat")<<std::endl;
	std::string outfile_name = std::regex_replace(om_filename, std::regex("/[^/]+$"), "/topology_defect.dat");
	std::ofstream os( outfile_name );
	os.precision(6);	
	os.setf(std::ios::fixed);
	os.setf(std::ios::showpoint);

    std::vector<long long> byte_positions;
    std::vector<long> timesteps;
    long long opos;


    //------- read and process at the same time since only the simplified mesh is needed here, no need for init_mesh_from_om() ----------------------
    //will still save timesteps and byte positions in two vectors if anyone needs them
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
 	//alernatingly read a timestep (long) and a mesh (.om) objects
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh_stripped;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh_stripped, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh_stripped, "edge_type");	
	opos = omfile.tellg();
	while (omfile >> timestep){
   		
   		OpenMesh::IO::read_mesh(mesh_stripped, omfile, _ext, ropt);

   		timesteps.push_back(timestep);
   		byte_positions.push_back(opos);
		std::cout<<"timestep "<<timestep<<" byte "<<opos<< std::endl;//" sizeof(long) "<<sizeof(long)<<std::endl;   
		opos = omfile.tellg();	

		//print_mesh_stripped(mesh_stripped);
		//topology_analyze_snapshot(mesh_stripped, timestep, os);	
		defect_analyze_snapshot(mesh_stripped, timestep, os);
	}
	omfile.close();
	os.close();

	//-----------------------------------------------------------------------------------------------------------------------------------


}


void process_final_structure(MyMesh & mesh, std::string data_folder){

	MyMesh mesh_stripped = get_stripped_mesh(mesh);
	dump_dat_snapshot(mesh_stripped, data_folder+"/vertices_final.dat", data_folder+"/faces_final.dat", data_folder+"/edges_final.dat");

	MyMesh::Point com;
	com = compute_COM(mesh);

	std::ofstream os( data_folder+"/final_stat_file.dat" );
	os.precision(6);	
	os.setf(std::ios::fixed);
	os.setf(std::ios::showpoint);	


	os<<"b_e\tn_v\tn_e\tn_f\tn3\tn4\tn5\tn6\tn7\tcomx\tcomy\tcomz"<<std::endl;

	os<<count_boundary_edges(mesh)<<"\t";
	os<<mesh.n_vertices()<<"\t";
	os<<mesh.n_edges()<<"\t";
	os<<mesh.n_faces()<<"\t";
	os<<count_vertices(mesh, 3, true)<<"\t";	
	os<<count_vertices(mesh, 4, true)<<"\t";
	os<<count_vertices(mesh, 5, true)<<"\t";
	os<<count_vertices(mesh, 6, true)<<"\t";
	os<<count_vertices(mesh, 7, true)<<"\t";
	os<<com[0]<<"\t";
	os<<com[1]<<"\t";
	os<<com[2]<<"\t";	
	os<<std::endl;

	os.close();


	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh_stripped.get_property_handle(ifprop, "face_type");
	mesh_stripped.get_property_handle(ihprop, "edge_type");
	mesh_stripped.property(ifprop).set_persistent(true);
	mesh_stripped.property(ihprop).set_persistent(true);


	std::ofstream output_om(data_folder+"/final_snapshot.om", std::ios::out | std::ios::binary);
	long t=0;		
	output_om<<t;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh_stripped, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return;
	  }	

  	output_om.close();
   	//dump_dat_snapshot(mesh,  dat_base + std::to_string(timestep) +"_vertices.dat", dat_base + std::to_string(timestep) +"_faces.dat", dat_base + std::to_string(timestep) +"_edges.dat");

	

	return;

}


/*
Returns true if two faces are connected by an edge. Goes by the internal index to have some
consistency between snapshots but this is not ideal and to be used only for the crack stuff
*/
bool are_faces_connected(MyMesh & mesh, int face1_ix, int face2_ix){
  MyMesh::FaceHandle face1, face2;

  for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
  	//std::cout<<(*fit).idx()<<" "<<face1_ix<<std::endl;
  	if ((*fit).idx()==face1_ix){
  		face1=*fit;
  		break;
  	}
  }

  for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
  	if ((*fit).idx()==face2_ix){
  		face2=*fit;
  		break;
  	}
  }  
  //face1=mesh.face_handle(face1_ix);
  //face2=mesh.face_handle(face2_ix);  

  //neighboring faces to face1
  for(MyMesh::FaceFaceIter it1 = mesh.ff_iter(face1); it1.is_valid(); ++it1) {
      if ((*it1)==(face2)){
        return true;     
      }  
  }
  return false;
}

std::vector<MyMesh::HalfedgeHandle> get_common_halfedges(MyMesh & mesh, MyMesh::FaceHandle face1, MyMesh::FaceHandle face2){
	std::vector<MyMesh::HalfedgeHandle> shared_halfedges;
	//halfedges of face1
	for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(face1); fh_it.is_valid(); ++fh_it){	
		for (MyMesh::FaceHalfedgeIter fh_it2 = mesh.fh_iter(face2); fh_it2.is_valid(); ++fh_it2){	
			if (*fh_it2 == mesh.opposite_halfedge_handle(*fh_it)){
				shared_halfedges.push_back(*fh_it2);
				shared_halfedges.push_back(*fh_it);
			}
		}
	}
	return shared_halfedges;
}

void reassign_edge_types(MyMesh & mesh, MyMesh & mesh_undeformed){
	std::vector<MyMesh::HalfedgeHandle> shared_halfedges;

	//reset all edge types to 0 of the undeformed mesh
	auto edge_props_stripped_undeformed = OpenMesh::HProp<int>(mesh_undeformed, "edge_type");
	for (MyMesh::HalfedgeIter h_it = mesh_undeformed.halfedges_sbegin();h_it != mesh_undeformed.halfedges_end(); ++h_it ){
		edge_props_stripped_undeformed[*h_it]=0;
	}

	//now go over the faces of the undeformed mesh and see if they are still connected
	//all faces
	for (MyMesh::FaceIter fit = mesh_undeformed.faces_sbegin(); fit!=mesh_undeformed.faces_end(); ++fit){
		//neighboring faces
		for(MyMesh::FaceFaceIter it1 = mesh_undeformed.ff_iter(*fit); it1.is_valid(); ++it1) {
			//see if these faces are still connected on the cracked mesh
			if (are_faces_connected(mesh, (*fit).idx(), (*it1).idx())){
				//do nothing if they are still connected
				//std::cout<<"still connected "<<std::endl;
			}
			else{
				shared_halfedges = get_common_halfedges(mesh_undeformed, *fit, *it1);
				if (shared_halfedges.size()!=2){
					std::cout<<"SOMETHING'S WRONG, they are neighbors but don't share exactly 2 halfedges"<<std::endl;
				}
				edge_props_stripped_undeformed[ shared_halfedges[0] ]=1;
				edge_props_stripped_undeformed[ shared_halfedges[1] ]=1;				
			}
		}

	}

	//now go over the faces of the cracked mesh
/*	for (MyMesh::FaceIter fit1 = mesh.faces_sbegin(); fit1!=mesh.faces_end(); ++fit1){
		for (MyMesh::FaceIter fit2 = mesh.faces_sbegin(); fit2!=mesh.faces_end(); ++fit2){
			//check if they used to be connected on the undeformed mesh
			if (are_faces_connected(mesh_undeformed, (*fit1).idx(), (*fit2).idx())){
				//check if they are still connected
				if (are_faces_connected(mesh_undeformed, (*fit1).idx(), (*fit2).idx())){

				}
			}
		}
	}
*/
	return;
}


int convert_om_to_dat_snapshots_undeformed_frame(std::string om_filename, std::string dat_base){
	//std::cout<<"reading";
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);

 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh, mesh_undeformed;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	

	auto face_props_stripped_undeformed =  OpenMesh::FProp<int>(mesh_undeformed, "face_type");
	auto edge_props_stripped_undeformed = OpenMesh::HProp<int>(mesh_undeformed, "edge_type");	

	//use the first snapshot as undeformed
	omfile >> timestep;
	OpenMesh::IO::read_mesh(mesh_undeformed, omfile, _ext, ropt);

	std::cout<<"undeformed snapshot loaded "<<std::endl;
	while (omfile >> timestep){
   		
   		OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   		//update the undeformed mesh edge types
   		reassign_edge_types(mesh, mesh_undeformed);


   		dump_dat_snapshot(mesh_undeformed,  dat_base + std::to_string(timestep) +"_vertices.dat", dat_base + std::to_string(timestep) +"_faces.dat", dat_base + std::to_string(timestep) +"_edges.dat");
		dump_lammps_snapshot(mesh_undeformed,  dat_base + std::to_string(timestep) +"lammps.dat");


	}
	omfile.close();
	return 1;

}





int make_capsid_full_specific(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	
	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	int facetype=0;
   	int hedgetype=0;
   	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it!=mesh.faces_end(); ++f_it){
	  	face_props_stripped[*f_it]=facetype;
	  	facetype++;

	  	for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			edge_props_stripped[*fh_it]=hedgetype;
			hedgetype++;	
			//std::cout<<"e_b"<< e_b<<" theta0 "<<theta0;
			//std::cout<<" edge_type "<<edge_type;//<<std::endl;
		}	

  	}

/*	std::ofstream edge_binding_rules(outfile_base+"edge_binding_rules.dat", std::ios::out);

  	int edge_type1, edge_type2;
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_type1=edge_props_stripped[*hit];
		edge_type2=edge_props_stripped[mesh.opposite_halfedge_handle(*hit)];
		edge_binding_rules<<edge_type1+1<<" "<<edge_type2+1<<std::endl;
    }  
    edge_binding_rules.close();



	std::ofstream subunit_types(outfile_base+"subunit_types.dat", std::ios::out);
   	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it!=mesh.faces_end(); ++f_it){
   		subunit_types<<face_props_stripped[*f_it]+1;
	  	for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
	  		subunit_types<<" "<<edge_props_stripped[*fh_it]+1;
	  	}
	  	subunit_types<<std::endl;

   	}
	subunit_types.close();

*/

	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	std::ofstream output_om(outfile_base+"full_specific.om", std::ios::out | std::ios::binary);

	system(("mkdir -p "+outfile_base  +"datfiles_full_specific").c_str());

	dump_vtk_snapshot(mesh, outfile_base  +"capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_double_edge_lammps.dat");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_lammps.dat");



	dump_dat_snapshot(mesh, outfile_base  + "datfiles_full_specific/vertices.dat", outfile_base  + "datfiles_full_specific/faces.dat", outfile_base  + "datfiles_full_specific/edges.dat");	
  	//ump_om(mesh, 0, output_om );
	//dump dihedrals and edge lengths
	print_capsid_data(mesh, outfile_base);


	//write the timestep first, then the mesh 	
	long t=0;		
	output_om<<t;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	

  	output_om.close();
   	//dump_dat_snapshot(mesh,  dat_base + std::to_string(timestep) +"_vertices.dat", dat_base + std::to_string(timestep) +"_faces.dat", dat_base + std::to_string(timestep) +"_edges.dat");

	
	omfile.close();


	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	t=0;		
	output_init_om<<t;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();

	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << t;
	dump_om(mesh, 0, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	



	return 1;

}









int make_capsid_full_specific_old(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	
	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	int facetype=0;
   	int hedgetype=0;
   	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it!=mesh.faces_end(); ++f_it){
	  	face_props_stripped[*f_it]=facetype;
	  	facetype++;

	  	for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			edge_props_stripped[*fh_it]=hedgetype;
			hedgetype++;	
			//std::cout<<"e_b"<< e_b<<" theta0 "<<theta0;
			//std::cout<<" edge_type "<<edge_type;//<<std::endl;
		}	

  	}

	std::ofstream edge_binding_rules(outfile_base+"edge_binding_rules.dat", std::ios::out);

  	int edge_type1, edge_type2;
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_type1=edge_props_stripped[*hit];
		edge_type2=edge_props_stripped[mesh.opposite_halfedge_handle(*hit)];
		edge_binding_rules<<edge_type1+1<<" "<<edge_type2+1<<std::endl;
    }  
    edge_binding_rules.close();



	std::ofstream subunit_types(outfile_base+"subunit_types.dat", std::ios::out);
   	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it!=mesh.faces_end(); ++f_it){
   		subunit_types<<face_props_stripped[*f_it]+1;
	  	for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
	  		subunit_types<<" "<<edge_props_stripped[*fh_it]+1;
	  	}
	  	subunit_types<<std::endl;

   	}
	subunit_types.close();


	//now hardcoding the Sigl lengths for T9. This needs to be automatically "optimized" by pushing vertices towards a sphere as Sigl did

	std::ofstream edge_lengths_file(outfile_base+"edge_lengths.dat", std::ios::out);
	//set all edges to 162/158
	std::vector<double> edge_lengths;
	for (int i=0; i<mesh.n_halfedges(); i++){
		edge_lengths.push_back(162.0/158.0);
	}	
	//outgoing/incoming edges from pentamers to 136/158
	//opposite edge to 5-fold vertex to 158/158
	MyMesh::HalfedgeHandle halfedge1, halfedge2;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if( mesh.valence(*v)==5 ){
			//first set all edges of the pentamer; then outgoing/incoming edges will be reset
			for (auto edge: get_affected_edges(mesh, *v)){
				halfedge1 = mesh.halfedge_handle(edge, 0);
				halfedge2 = mesh.halfedge_handle(edge, 1);
				edge_type1=edge_props_stripped[halfedge1];
				edge_type2=edge_props_stripped[halfedge2];		
				
				edge_lengths[edge_type1]=158.0/158.0;
				edge_lengths[edge_type2]=158.0/158.0;						
			}


			for (MyMesh::VertexEdgeIter ve_it=mesh.ve_iter(*v); ve_it.is_valid(); ++ve_it){
				halfedge1 = mesh.halfedge_handle(*ve_it, 0);
				halfedge2 = mesh.halfedge_handle(*ve_it, 1);
				edge_type1=edge_props_stripped[halfedge1];
				edge_type2=edge_props_stripped[halfedge2];		
				
				edge_lengths[edge_type1]=136.0/158.0;
				edge_lengths[edge_type2]=136.0/158.0;		
			}

		}

	}

	for (int i=0; i<mesh.n_halfedges(); i++){
		edge_lengths_file<<i+1<<" "<<edge_lengths[i]<<std::endl;
	}		
	edge_lengths_file.close();



	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	std::ofstream output_om(outfile_base+"full_specific.om", std::ios::out | std::ios::binary);
  	//ump_om(mesh, 0, output_om );


	//write the timestep first, then the mesh 	
	long t=0;		
	output_om<<t;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	

  	output_om.close();
   	//dump_dat_snapshot(mesh,  dat_base + std::to_string(timestep) +"_vertices.dat", dat_base + std::to_string(timestep) +"_faces.dat", dat_base + std::to_string(timestep) +"_edges.dat");

	
	omfile.close();


	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	t=0;		
	output_init_om<<t;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();




	return 1;

}


//neighbor vertices to current_vertex in circular order such that the first one is prev_vertex
std::vector<MyMesh::VertexHandle> get_neighbor_vertices_in_order(MyMesh & mesh, MyMesh::VertexHandle prev_vertex, MyMesh::VertexHandle current_vertex){

   	std::vector <MyMesh::VertexHandle> neighbor_vertices;
	for (MyMesh::VertexOHalfedgeIter oh = mesh.voh_iter(current_vertex); oh.is_valid(); ++oh ){
		 neighbor_vertices.push_back(mesh.to_vertex_handle(*oh) );
	}

	//find the index of prev_vertex
	int ii=-1;
	for (int i=0; i<neighbor_vertices.size(); i++ ){
		if (prev_vertex == neighbor_vertices[i]){
			ii=i;
			break;
		}

	}

	if (ii==-1){
		std::cout<<"Something's wrong, could not find prev_vertex in neighbor_vertices"<<std::endl;
	}

	//roll the array to move prev_vertex to first position
	 std::rotate(neighbor_vertices.begin(),neighbor_vertices.begin()+ii,neighbor_vertices.end());

	 return neighbor_vertices;

}

//returns true if vertices of two faces are of the same type, in the same order
bool are_faces_of_same_type_by_vertices(MyMesh & mesh, MyMesh::FaceHandle face1, MyMesh::FaceHandle face2){
	std::vector<MyMesh::VertexHandle> fv1;
	std::vector<MyMesh::VertexHandle> fv2;
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	for (MyMesh::FaceVertexIter v = mesh.fv_iter(face1); v.is_valid(); ++v ){
		fv1.push_back(*v);
	}

	for (MyMesh::FaceVertexIter v = mesh.fv_iter(face2); v.is_valid(); ++v ){
		fv2.push_back(*v);
	}


	bool match;
	for (int r=0; r<=3; r++){
		match=true;
		std::rotate(fv2.begin(),fv2.begin()+1,fv2.end());
		for (int i=0; i<3; i++){
			if(vertex_props_stripped[ fv1[i] ]!=vertex_props_stripped[ fv2[i] ]){
				match=false;
				break;
			}
		}
		if (match){
			break;
		}
	}

	return match;

}


//if surrounding faces are the same type in same order, two vertices are considered to be in equivalent environments, thus the same
bool are_vertices_of_same_type_by_faces(MyMesh & mesh, MyMesh::VertexHandle v1, MyMesh::VertexHandle v2){
	if (mesh.valence(v1)!=mesh.valence(v2)){
		return false;
	}


	std::vector<MyMesh::FaceHandle> f1;
	std::vector<MyMesh::FaceHandle> f2;
	auto face_props_stripped = OpenMesh::FProp<int>(mesh, "face_type");	

	for (MyMesh::VertexFaceIter f = mesh.vf_iter(v1); f.is_valid(); ++f ){
		f1.push_back(*f);
	}

	for (MyMesh::VertexFaceIter f = mesh.vf_iter(v2); f.is_valid(); ++f ){
		f2.push_back(*f);
	}


	bool match;
	for (int r=0; r<=6; r++){
		match=true;
		std::rotate(f2.begin(),f2.begin()+1,f2.end());
		//test current rotation; all surrounding face types should match, in order
		for (int i=0; i<f2.size(); i++){
			if(face_props_stripped[ f1[i] ]!=face_props_stripped[ f2[i] ]){
				match=false;
				break;
			}
		}
		if (match){
			break;
		}
	}

	return match;

}


//color vertices assuming faces are properly colored; it also assumed that a symmetry in surrounding faces defines a vertex type
int color_vertices_by_faces(MyMesh & mesh){

	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");	
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	int vtype=-1;

	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		vertex_props_stripped[*v]=vtype;
	}	

	vtype=0;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){

		if (vertex_props_stripped[*v]==-1){
			vertex_props_stripped[*v]=vtype;
			for (MyMesh::VertexIter v2 = mesh.vertices_sbegin(); v2!=mesh.vertices_end(); ++v2){
				if (are_vertices_of_same_type_by_faces(mesh, v, v2)  ){
					vertex_props_stripped[*v2]=vtype;
				}
			}
			vtype++;
		}

	}
	return 0;

}

//given a face type, returns faces of that type
std::vector<MyMesh::FaceHandle> get_faces_by_type(MyMesh & mesh, int ftype){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	std::vector <MyMesh::FaceHandle> faces;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if (face_props_stripped[*fit]==ftype){
				faces.push_back(*fit);
			}
	}

	return faces; 
}

//returns all faces
std::vector<MyMesh::FaceHandle> get_faces_by_type(MyMesh & mesh){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	std::vector <MyMesh::FaceHandle> faces;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				faces.push_back(*fit);
		
	}

	return faces; 
}


//same as get_faces_by_type, but here the property to filter for is face_type_ck. It is used to save original CK types before merging
std::vector<MyMesh::FaceHandle> get_faces_by_ck_type(MyMesh & mesh, int ftype_ck){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type_ck");
	std::vector <MyMesh::FaceHandle> faces;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if (face_props_stripped[*fit]==ftype_ck){
				faces.push_back(*fit);
			}
	}

	return faces; 
}


template <typename t>
std::vector<std::vector<t> > GetUniqueRows(std::vector<std::vector<t> > input)
{
    std::sort(input.begin(), input.end());
    input.erase(std::unique(input.begin(), input.end()), input.end());
    return input;
}

//get number of cross-bindings for a given face type ftype
// For each edge type it counts how many other edge types it binds to. Subtract 1 (if it only binds to another type, that's not a cross bond) and sums for all edge types.
int get_number_of_cross_bindings(MyMesh & mesh, int ftype, bool all_types=false){
	std::vector<MyMesh::FaceHandle> ftype_faces;
	if (all_types){
		ftype_faces = get_faces_by_type(mesh);
	}
	else{
		ftype_faces = get_faces_by_type(mesh, ftype);
	} 
	std::vector<std::vector<int>> bonds;
	MyMesh::HalfedgeHandle he1, he2;
	int etype1, etype2;
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	

	for (auto face: ftype_faces){
		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(face); fh.is_valid(); ++fh){
			he1=*fh;
			he2=mesh.opposite_halfedge_handle(he1);

			etype1=edge_props_stripped[he1];
			etype2=edge_props_stripped[he2];

			bonds.push_back(std::vector<int>());
			bonds[bonds.size()-1].push_back(etype1);
			bonds[bonds.size()-1].push_back(etype2);

			bonds.push_back(std::vector<int>());
			bonds[bonds.size()-1].push_back(etype2);
			bonds[bonds.size()-1].push_back(etype1);

		}
	}


	bonds=GetUniqueRows(bonds);
	std::vector<int> first_column;
	for (int ir=0; ir<bonds.size(); ir++){
		first_column.push_back(bonds[ir][0]);
	}

	std::sort( first_column.begin(), first_column.end() );
	first_column.erase( std::unique( first_column.begin(), first_column.end() ), first_column.end() );

	//probably double counts each pair
	return bonds.size()-first_column.size();
	//not correct
	//return bonds.size() - GetUniqueRows(bonds).size();
}

//once vertices and faces are colored, it colors halfedges
int color_edges_by_vertices_and_faces(MyMesh & mesh){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	
	MyMesh::VertexHandle vf1, vf2, vt1, vt2;
	MyMesh::FaceHandle f1, f2, f1o, f2o;

	int etype=-1;
	for (MyMesh::HalfedgeIter h_it = mesh.halfedges_sbegin();h_it != mesh.halfedges_end(); ++h_it ){
		edge_props_stripped[*h_it]=etype;
	}	

	etype=0;
	for (int ftype=0; ftype<mesh.n_faces(); ftype++){
		for (auto face: get_faces_by_type(mesh, ftype)){
			for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(face); fh.is_valid(); ++fh){
				if (edge_props_stripped[*fh]==-1 ){
					edge_props_stripped[*fh]=etype;
					//color all its mirrors
					for (MyMesh::HalfedgeIter h_it = mesh.halfedges_sbegin();h_it != mesh.halfedges_end(); ++h_it ){
						vf1 = mesh.from_vertex_handle(*h_it);
						vt1 = mesh.to_vertex_handle(*h_it);

						vf2 = mesh.from_vertex_handle(*fh);
						vt2 = mesh.to_vertex_handle(*fh); 	

						//parent triangle types of halfedges and opposite halfedges match
						f1 = mesh.face_handle(*h_it);
						f2 = mesh.face_handle(*fh);

						f1o = mesh.face_handle(mesh.opposite_halfedge_handle(*h_it));
						f2o = mesh.face_handle(mesh.opposite_halfedge_handle(*fh));						


						if( (vertex_props_stripped[vf1] == vertex_props_stripped[vf2] )	& (vertex_props_stripped[vt1]==vertex_props_stripped[vt2]) & (face_props_stripped[f1]==face_props_stripped[f2]) & (face_props_stripped[f1o]==face_props_stripped[f2o]) ){
							edge_props_stripped[*h_it]=etype;
						}
					}

					etype++;
				}
			}

		}
	}
	return 0;
}


//for each current face we need its previous face for proper orientation of neighbors
int color_next_neighbors(MyMesh & mesh, std::vector<MyMesh::FaceHandle> current_faces, std::vector<MyMesh::FaceHandle> prev_faces, int ftype){
	//static int ftype=2;
	int ftype_current;

	if (current_faces.size()==0){
		return 0;
	}

	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	bool all_neighbors_colored, newly_colored;
	int new_colors;
	std::vector<MyMesh::FaceHandle> next_faces, next_prev_faces;
    MyMesh::FaceHandle current_face, prev_face, neighbor_face;
    MyMesh::HalfedgeHandle hedge;

    std::vector<int> current_faces_types;
    for (int i=0; i<current_faces.size(); i++){
    	current_faces_types.push_back( face_props_stripped[ current_faces[i]]  );
    }
    std::sort( current_faces_types.begin(), current_faces_types.end() );
	current_faces_types.erase( std::unique( current_faces_types.begin(), current_faces_types.end() ), current_faces_types.end() );


    new_colors=0;
    for (int nn=0; nn<=1; nn++){
    	newly_colored=false;

    	for (auto ft: current_faces_types){

			for (int i=0; i<current_faces.size(); i++){   //should filter current_faces by type and color of the same types at once. Then increase new_colors and proceed to next type

				current_face = current_faces[i];
				prev_face = prev_faces[i];

				if (face_props_stripped[current_face]!=ft){
					continue;
				}

				//place hedge to the common edge between current_face and prev_face
				hedge = mesh.halfedge_handle(current_face);
				for (int j=0; j<3; j++){
					if (mesh.face_handle( mesh.opposite_halfedge_handle(hedge) )==prev_face){
						//std::cout<<"FOUND COMMON EDGE"<<std::endl;
						break;
					}
					hedge=mesh.next_halfedge_handle(hedge);

				}  	

		
				for (int j=0; j<=nn; j++){
					hedge=mesh.next_halfedge_handle(hedge);	
				}


				neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
				if(face_props_stripped[ neighbor_face ] ==-1 ){
					face_props_stripped[ neighbor_face ]=ftype + new_colors;//+nn; 

					next_faces.push_back(neighbor_face);	
					next_prev_faces.push_back(current_face);
				
					newly_colored=true;	

				}

	    	}

	    	if (newly_colored){
				new_colors++;
				newly_colored=false;	
			}
		}	
	}


/**********Worked for Greg's small icosahedra, T<25*************
    new_colors=0;
    for (int nn=0; nn<=1; nn++){
    	newly_colored=false;
		for (int i=0; i<current_faces.size(); i++){   //should filter current_faces by type and color of the same types at once. Then increase new_colors and proceed to next type

			current_face = current_faces[i];
			prev_face = prev_faces[i];

			//place hedge to the common edge between current_face and prev_face
			hedge = mesh.halfedge_handle(current_face);
			for (int j=0; j<3; j++){
				if (mesh.face_handle( mesh.opposite_halfedge_handle(hedge) )==prev_face){
					//std::cout<<"FOUND COMMON EDGE"<<std::endl;
					break;
				}
				hedge=mesh.next_halfedge_handle(hedge);

			}  	

	
			for (int j=0; j<=nn; j++){
				hedge=mesh.next_halfedge_handle(hedge);	
			}


			neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
			if(face_props_stripped[ neighbor_face ] ==-1 ){
				face_props_stripped[ neighbor_face ]=ftype + new_colors;//+nn; 

				next_faces.push_back(neighbor_face);	
				next_prev_faces.push_back(current_face);
			
				newly_colored=true;	

			}

    	}

    	if (newly_colored){
			new_colors++;	
		}	


	}

	****************************************/


	dump_vtk_snapshot(mesh, "/home/btyukodi/testdatafolder/specific_coloring/"+std::to_string(ftype)+"_rec_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");


	if (next_faces.size()==0){
		return 0;
	}	

	std::cout<<"next_faces.size() "<<next_faces.size()<<std::endl;
	//ftype+=new_colors;
	color_next_neighbors(mesh, next_faces, next_prev_faces, ftype+new_colors);
	


	return 0;
}




int color_faces_Sigl_specific_bak(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	

	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			face_props_stripped[*fit]=-1;
	}

  	int ftype=0;	


   	std::vector <MyMesh::VertexHandle> pentamer_vertices;
   	std::vector <MyMesh::FaceHandle> pentamer_faces, current_faces, next_faces, prev_faces;
   	MyMesh::FaceHandle nextface;

	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
		    for (MyMesh::VertexFaceIter vf = mesh.vf_iter(*v); vf.is_valid(); ++vf ){
		        pentamer_faces.push_back(*vf);
		    	face_props_stripped[ *vf ] = ftype;
		    }  
		}
	}  		

	ftype++;
	for (auto f0: pentamer_faces ){
 		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(f0); fh.is_valid(); ++fh){
  				//if next one is not pentamer
  				nextface=mesh.face_handle(  mesh.opposite_halfedge_handle(*fh ) ) ;
  				if ( face_props_stripped[ nextface ]!=0 ){
  					current_faces.push_back(nextface);
  					prev_faces.push_back(f0);
  					face_props_stripped[nextface]=ftype;
  				}
  			
  		}

	}


	color_next_neighbors(mesh, current_faces, prev_faces, 2);
	dump_vtk_snapshot(mesh, outfile_base  +"00vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");



	//---------- move to wrapper --------------
	color_vertices_by_faces(mesh);
	dump_lammps_snapshot(mesh,  outfile_base  +"0lammps.dat");

	color_edges_by_vertices_and_faces(mesh);
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"0_dd_lammps.dat");

	print_mesh_stripped(mesh);

	return 0;  	   	

}


int color_faces_Sigl_specific(MyMesh & mesh){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");

	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			face_props_stripped[*fit]=-1;
	}

  	int ftype=0;	


   	std::vector <MyMesh::VertexHandle> pentamer_vertices;
   	std::vector <MyMesh::FaceHandle> pentamer_faces, current_faces, next_faces, prev_faces;
   	MyMesh::FaceHandle nextface;

	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
		    for (MyMesh::VertexFaceIter vf = mesh.vf_iter(*v); vf.is_valid(); ++vf ){
		        pentamer_faces.push_back(*vf);
		    	face_props_stripped[ *vf ] = ftype;
		    }  
		}
	}  		

	ftype++;
	for (auto f0: pentamer_faces ){
 		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(f0); fh.is_valid(); ++fh){
  				//if next one is not pentamer
  				nextface=mesh.face_handle(  mesh.opposite_halfedge_handle(*fh ) ) ;
  				if ( face_props_stripped[ nextface ]!=0 ){
  					current_faces.push_back(nextface);
  					prev_faces.push_back(f0);
  					face_props_stripped[nextface]=ftype;
  				}
  			
  		}

	}


	color_next_neighbors(mesh, current_faces, prev_faces, 2);


	return 0;  	   	

}


int make_capsid_Sigl_specific(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	

	color_faces_Sigl_specific(mesh);

	color_vertices_by_faces(mesh);

	color_edges_by_vertices_and_faces(mesh);

	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	system(("mkdir -p "+outfile_base  +"datfiles_Sigl_specific").c_str());	
	std::ofstream output_om(outfile_base+"Sigl_specific.om", std::ios::out | std::ios::binary);	
	//write the timestep first, then the mesh 	
		
	output_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	


  	output_om.close();	



	dump_vtk_snapshot(mesh, outfile_base  +"capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_double_edge_lammps.dat");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_lammps.dat");



	dump_dat_snapshot(mesh, outfile_base  + "datfiles_Sigl_specific/vertices.dat", outfile_base  + "datfiles_Sigl_specific/faces.dat", outfile_base  + "datfiles_Sigl_specific/edges.dat");


	//dump dihedrals and edge lengths
	print_capsid_data(mesh, outfile_base);

	//std::cout<<outfile_base<<std::endl;
	print_mesh_stripped(mesh);


	//create single subunit and pentamer seeds
	//find a pentamer vertex
	MyMesh::VertexHandle vpentamer;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
			vpentamer=(*v);
			break;
		}
	}


	auto to_remove =  OpenMesh::FProp<int>(mesh, "to_remove");	
    for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
    	to_remove[*fit]=1;
    }

	//mark its neighboring faces

	for (MyMesh::VertexFaceIter vf = mesh.vf_iter(vpentamer); vf.is_valid(); ++vf ){
		to_remove[*vf]=0;
	}

	//std::vector<MyMesh::FaceHandle> rmlist;
	//bool more_deleted=true;
	//while (more_deleted){
	//	more_deleted=false;
	    for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
	    	if(to_remove[*fit]==1){
	    		mesh.delete_face(*fit);
	  //  		more_deleted=true;
	    		//std::cout<<"DELETED "<<mesh.n_faces()<<std::endl;
	  //  		break;
	    		//rmlist.push_back(*fit);
	    	}
	    }
	//}
    /*for (auto f: rmlist){
    	mesh.delete_face(f);
    }*/

    mesh.garbage_collection();

    long long t=0;

	std::ofstream outfile_om_pentamer_seed(outfile_base+"pentamer_seed.om", std::ios::out | std::ios::binary);
	outfile_om_pentamer_seed << t;
	dump_om(mesh, 0, outfile_om_pentamer_seed);
	outfile_om_pentamer_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << t;
	dump_om(mesh, 0, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	

return 0;

}


//leave this here for history to remind me the shameful attempt to avoid recursion
int make_capsid_Sigl_specific_crap(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	//reset coloring to all vertices
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		vertex_props_stripped[*v]=-1;
	} 

	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			face_props_stripped[*fit]=-1;
	}	  	

   	//find pentamer vertices; set all their type to 0
   	int vtype=0;
   	int ftype=0;
   	int etype=0;
   	std::vector <MyMesh::VertexHandle> pentamer_vertices;
   	std::vector <MyMesh::FaceHandle> pentamer_faces, current_faces, next_faces, prev_faces;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
			pentamer_vertices.push_back(*v);
			vertex_props_stripped[*v]=vtype;

		    for (MyMesh::VertexFaceIter vf = mesh.vf_iter(*v); vf.is_valid(); ++vf ){
		        pentamer_faces.push_back(*vf);
		    	//current_faces.push_back(*vf);
		    	face_props_stripped[ *vf ] = ftype;
		    }  

		}

	}

	ftype++;
	MyMesh::FaceHandle nextface, current_face, prev_face, neighbor_face;
	MyMesh::HalfedgeHandle hedge;
	for (auto f0: pentamer_faces ){

 		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(f0); fh.is_valid(); ++fh){
  				//if next one is not pentamer
  				nextface=mesh.face_handle(  mesh.opposite_halfedge_handle(*fh ) ) ;
  				if ( face_props_stripped[ nextface ]!=0 ){
  					current_faces.push_back(nextface);
  					//face_props_stripped[nextface]=ftype;
  					prev_faces.push_back(f0);
  				}
  			
  		}

	}


   	std::vector <MyMesh::VertexHandle> prev_vertices, current_vertices, next_vertices, prev_vertices_cp, current_vertices_cp;
   	MyMesh::VertexHandle current_vertex, next_vertex, prev_vertex;
	//find pentamer edge vertices
	//MAY NOT WORK FOR SMALL T NUMBERS WHERE PENTAMER CORNERS TOUCH EACH OTHER. PROBABLY NEEDS SOME EXCEPTION MANAGEMENT
	vtype++;
	for (auto v0: pentamer_vertices ){
		for(MyMesh::VertexVertexIter v= mesh.vv_iter(v0); v.is_valid(); ++v) {
			current_vertices.push_back(*v);
			prev_vertices.push_back(v0);

		}
	}




	bool already_colored=false;
	bool pentamer_hit=false;
	bool all_vertices_colored, all_faces_colored;

	//color vertices based on their symmetry
	for (int ii=0; ii<200; ii++){

	   	for (int nn=1; nn<6; nn++){
	   		next_vertices.clear();
	   		already_colored=false;
	   		pentamer_hit=false;
	   		for (int i=0; i<current_vertices.size(); i++){

	   			//color current vertex if not colored already
	   			if (  vertex_props_stripped[ current_vertices[i]  ]==-1 ){
	   				vertex_props_stripped[ current_vertices[i]  ]=vtype;
	   			}
	   			else{
	   				already_colored=true;
	   				//break;
	   			}
	   			if (mesh.valence(current_vertices[i])==5){
	   				pentamer_hit=true;
	   			}
			}
			if (pentamer_hit){
				break;
			}

			if (!already_colored){
				vtype++;
			}


	   		for (int i=0; i<current_vertices.size(); i++){

	   			current_vertex = current_vertices[i];
	   			prev_vertex = prev_vertices[i];
	   			//get current vertex neighbor at nn direction
	   			next_vertex = get_neighbor_vertices_in_order(mesh, prev_vertex, current_vertex)[nn];	   			

	   			next_vertices.push_back(next_vertex);
	   		}

	   		//Technically new paths should start from already colored nodes as well. It's unclear where to stop this because already colored nodes can still have uncolored directions nn
	   		// nn=1,6 guarantees that 0 (prev vertex) is not visited again 
	   		for (int i=0; i<current_vertices.size(); i++){
   			
	   			prev_vertices[i]=current_vertices[i];
	   			current_vertices[i] = next_vertices[i];
	   		}

	   		
	   	}

	    all_vertices_colored=true;
	    for (MyMesh::VertexIter it = mesh.vertices_sbegin(); it != mesh.vertices_end(); ++it){
		    if (vertex_props_stripped[ *it  ]==-1){
		        all_vertices_colored=false;
		        break;
		    }
	    }
	    if (all_vertices_colored){
	    	break;
	    }    

	}


	//turns out vertex coloring is not enough to identify faces (at least for small T, see T7)
	//need to color faces in a similar manner to vertices
	for (int ii=0; ii<10; ii++){

	   	for (int nn=0; nn<2; nn++){
	   		//dump_vtk_snapshot(mesh, outfile_base  + std::to_string(ii)+"_"+ std::to_string(nn)+"_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	   		dump_vtk_snapshot(mesh, outfile_base  + std::to_string(2*ii+nn)+"_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	   		//next_faces.clear();
	   		already_colored=false;
	   		pentamer_hit=false;
	   		for (int i=0; i<current_faces.size(); i++){

	   			//color current face if not colored already
	   			if (  face_props_stripped[ current_faces[i]  ]==-1 ){
	   				face_props_stripped[ current_faces[i]  ]=ftype;
	   			}
	   			else{
	   				already_colored=true;
	   				//break;
	   			}
	   			if ( face_props_stripped[ current_faces[i]  ]==0){
	   				pentamer_hit=true;
	   			}
			}
			if (pentamer_hit){
				std::cout<<"Pentamer hit "<<ii<<" "<<nn<<std::endl;
				break;
			}

			if (!already_colored){
				ftype++;
			}


			next_faces.clear();
	   		for (int i=0; i<current_faces.size(); i++){

	   			current_face = current_faces[i];
	   			prev_face = prev_faces[i];
	   			//get current vertex neighbor at nn direction
	   			//next_vertex = get_neighbor_vertices_in_order(mesh, prev_vertex, current_vertex)[nn];	 

	   			//place hedge to the common edge between current_face and prev_face
	   			hedge = mesh.halfedge_handle(current_face);
	   			for (int j=0; j<3; j++){
	   				if (mesh.face_handle( mesh.opposite_halfedge_handle(hedge) )==prev_face){
	   					//std::cout<<"FOUND COMMON EDGE"<<std::endl;
	   					break;
	   				}
	   				hedge=mesh.next_halfedge_handle(hedge);

	   			}  	

				hedge=mesh.next_halfedge_handle(hedge);	
	   			for (int j=0; j<=nn; j++){
	   				hedge=mesh.next_halfedge_handle(hedge);	   				
	   			}		

	   			neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
	   			next_faces.push_back(neighbor_face);

	   		}

	   		//std::cout<<"next_faces.size()  "<<next_faces.size()<<std::endl;

	   		//Technically new paths should start from already colored nodes as well. It's unclear where to stop this because already colored nodes can still have uncolored directions nn
	   		// nn=1,6 guarantees that 0 (prev vertex) is not visited again 
	   		for (int i=0; i<current_faces.size(); i++){
   			
	   			prev_faces[i]=current_faces[i];
	   			current_faces[i] = next_faces[i];
	   		}

	   		
	   	}

/*	    all_faces_colored=true;
	    for (MyMesh::FaceIter it = mesh.faces_sbegin(); it != mesh.faces_end(); ++it){
		    if (face_props_stripped[ *it  ]==-1){
		        all_faces_colored=false;
		        break;
		    }
	    }
	    if (all_faces_colored){
	    	break;
	    }    
*/
	}



	//now that all vertices are colored, color the faces
/*	ftype=-1;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			face_props_stripped[*fit]=ftype;
	}

	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		//if not colored yet, color it
		if (face_props_stripped[*fit]==-1){
			ftype++;
			face_props_stripped[*fit]=ftype;
		}
		//also color all its mirrors
		for (MyMesh::FaceIter fit2 = mesh.faces_sbegin(); fit2!=mesh.faces_end(); ++fit2){
			if (face_props_stripped[*fit2]==-1){
				if (are_faces_of_same_type_by_vertices(mesh, *fit, *fit2) ){
						face_props_stripped[*fit2]=ftype;
				}
			}
		}
	}
*/
	//now that faces are colored, color the edges;
	//identifying equivalent edge contacts. Presumably if the to/from vertices are the same and also the neighboring triangles are the same, then two contacts are equivalent
	MyMesh::VertexHandle vf1, vf2, vt1, vt2;
	MyMesh::HalfedgeHandle oh;
	MyMesh::FaceHandle f1, f2, f3, f4;
	etype=-1;
	for (MyMesh::HalfedgeIter h_it = mesh.halfedges_sbegin();h_it != mesh.halfedges_end(); ++h_it ){
		edge_props_stripped[*h_it]=-1;
	}	


	//maybe go over faces and circle halfedges to match colors
	//for (MyMesh::HalfedgeIter h_it = mesh.halfedges_sbegin();h_it != mesh.halfedges_end(); ++h_it ){
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		for (MyMesh::FaceHalfedgeIter h_it = mesh.fh_iter(*fit); h_it.is_valid(); ++h_it){


		if(edge_props_stripped[*h_it]==-1){
			etype++;
			edge_props_stripped[*h_it]=etype;
			//oh = mesh.opposite_halfedge_handle(*h_it);
			//edge_props_stripped[oh]=etype;

		}
		//also color all its mirrors
		for (MyMesh::HalfedgeIter h_it2 = mesh.halfedges_sbegin();h_it2 != mesh.halfedges_end(); ++h_it2 ){
			if(edge_props_stripped[*h_it2]==-1){
				//from and to vertex types match
				vf1 = mesh.from_vertex_handle(*h_it);
				vt1 = mesh.to_vertex_handle(*h_it);

				vf2 = mesh.from_vertex_handle(*h_it2);
				vt2 = mesh.to_vertex_handle(*h_it2); 	

				//parent triangle types of halfedges and opposite halfedges match
				f1 = mesh.face_handle(*h_it);
				f2 = mesh.face_handle(*h_it2);		
				
				oh = mesh.opposite_halfedge_handle(*h_it);
				f3 = mesh.face_handle(oh);

				oh = mesh.opposite_halfedge_handle(*h_it2);
				f4 = mesh.face_handle(oh);						

				if ((vertex_props_stripped[vf1]==vertex_props_stripped[vf2]) & (vertex_props_stripped[vt1]==vertex_props_stripped[vt2]) & (face_props_stripped[f1]==face_props_stripped[f2]) & (face_props_stripped[f3]==face_props_stripped[f4]) ){
								edge_props_stripped[*h_it2]=etype;
								//oh = mesh.opposite_halfedge_handle(*h_it2);
								//edge_props_stripped[oh]=etype;
				} 



			}			
		}		

	}		

}

	  //FOR OVITO ONLY to DEBUG
	/*for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if(vertex_props_stripped[*v]==-1){
			vertex_props_stripped[*v]=vtype+1;
		}
	}   */	  
	dump_lammps_snapshot(mesh,  outfile_base  +"0lammps.dat");

	dump_vtk_snapshot(mesh, outfile_base  +"00vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"0lammps_double_edge.dat");

	print_mesh_stripped(mesh);


	return 1;
 }


 int print_capsid_data(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

   	std::ofstream os1( outfile_base+"dihedral_data.dat" );
   	std::ofstream os2( outfile_base+"bondlength_data.dat" );   	
	os1.precision(6);	
	os1.setf(std::ios::fixed);
	os1.setf(std::ios::showpoint);   

	os2.precision(6);	
	os2.setf(std::ios::fixed);
	os2.setf(std::ios::showpoint);   			

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

	for (MyMesh::EdgeIter e_it = mesh.edges_sbegin();e_it != mesh.edges_end(); ++e_it ){

		os1<<edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<< edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<< mesh.calc_dihedral_angle(*e_it)<<std::endl;
		os1<<edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<< edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<< mesh.calc_dihedral_angle(*e_it)<<std::endl;	



		os2<<edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<<mesh.calc_edge_length(*e_it)<<std::endl;	
		os2<<edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<<mesh.calc_edge_length(*e_it)<<std::endl;				

	}

	os1.close();
	os2.close();	

return 0;
}



int print_capsid_data(MyMesh & mesh, std::string outfile_base){

	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

   	std::ofstream os1( outfile_base+"dihedral_data.dat" );
   	std::ofstream os2( outfile_base+"bondlength_data.dat" );   	
	os1.precision(6);	
	os1.setf(std::ios::fixed);
	os1.setf(std::ios::showpoint);   

	os2.precision(6);	
	os2.setf(std::ios::fixed);
	os2.setf(std::ios::showpoint);   			


	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	


	for (MyMesh::EdgeIter e_it = mesh.edges_sbegin();e_it != mesh.edges_end(); ++e_it ){

		os1<<edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<< edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<< mesh.calc_dihedral_angle(*e_it)<<std::endl;
		os1<<edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<< edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<< mesh.calc_dihedral_angle(*e_it)<<std::endl;	



		os2<<edge_props_stripped[mesh.halfedge_handle(*e_it,0)]+1<<"\t"<<mesh.calc_edge_length(*e_it)<<std::endl;	
		os2<<edge_props_stripped[mesh.halfedge_handle(*e_it,1)]+1<<"\t"<<mesh.calc_edge_length(*e_it)<<std::endl;				

	}

	os1.close();
	os2.close();	

return 0;
}


int push_vertices_to_sphere(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);


	MyMesh::Point com = MyMesh::Point(0,0,0);
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if (mesh.valence(*v)==5){
			com+=mesh.point(*v) / 12.0;
		}
	}
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		mesh.set_point(*v, mesh.point(*v) - com );
	}

	MyMesh::Point p, er;
	double R=0.0;
	for(MyMesh::VertexIter vit = mesh.vertices_sbegin(); vit != mesh.vertices_end(); ++vit) {
		if (mesh.valence(*vit)==5){
			//R+=p.norm();
			p=mesh.point(*vit);
			std::cout<<"R "<<p.norm()<<std::endl;
			R+=p.norm() / 12.0;
		}
	}


	double l_avg=0.0;
	double l2_avg=0.0;
	double l;
	double lmax=0.0, lmin=1000;
	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		l = mesh.calc_edge_length(*e_it);
		if (l<lmin){
			lmin=l;
		}
		if (l>lmax){
			lmax=l;
		}

		l_avg+=l/mesh.n_edges();
		l2_avg+=l*l/mesh.n_edges();
	}

	std::cout<<"<l> "<<l_avg<<std::endl;
	std::cout<<"std "<< sqrt(l2_avg - l_avg*l_avg) <<std::endl;
	std::cout<<"std / <l> "<< sqrt(l2_avg - l_avg*l_avg) / l_avg<<std::endl;
	std::cout<<"lmax - lmin  "<< (lmax-lmin) <<std::endl;	
	std::cout<<"lmax - lmin / <l> "<< (lmax-lmin) / l_avg<<std::endl;


	//push vertices to the sphere surface
	for(MyMesh::VertexIter vit = mesh.vertices_sbegin(); vit != mesh.vertices_end(); ++vit) {
		if (mesh.valence(*vit)!=5){
			//R+=p.norm();
			p=mesh.point(*vit);
			er=p.normalize();

			mesh.set_point(*vit, er*R);
		}
	}	


	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		std::cout<<"dihedral "<<mesh.calc_dihedral_angle(*e_it)<<std::endl;
		std::cout<<"edge "<<mesh.calc_edge_length(*e_it)<<std::endl;		
	}

	dump_lammps_snapshot(mesh, "/home/btyukodi/testdatafolder/specific_coloring/faceting/pushed_to_sphere.lammps");

   	return 0;
}


//return the closest vertex to a point
//needed to construct the faceted mesh from vertex handles
MyMesh::VertexHandle find_nearest_vertex(MyMesh & mesh, MyMesh::Point p){
	double dmin=1e10;
	double d;
	MyMesh::VertexHandle vc;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		d=(mesh.point(*v)-p).sqrnorm();
		if (d<dmin){
			dmin=d;
			vc=*v;
		}
	}
	return vc;
}


//recursively numbers little triangles in the big facet triangle. Each facet has its own numbering. Relative to base vertices defined below
int number_little_triangles(MyMesh & mesh, MyMesh::HalfedgeHandle current_he, int & triangle_nr){
	auto mesh_face_number =  OpenMesh::FProp<int>(mesh, "face_number");
	auto triangle_number =  OpenMesh::FProp<int>(mesh, "triangle_number");
	auto he_number = 	OpenMesh::HProp<int>(mesh, "halfedge_number");
	int facet_number;

	MyMesh::FaceHandle current_face=mesh.face_handle(current_he);
	MyMesh::FaceHandle prev_face=mesh.face_handle(mesh.opposite_halfedge_handle(current_he));

	//if slipped onto another facet
	if (mesh_face_number[current_face]!=mesh_face_number[prev_face]){
		std::cout<<"=== Another face "<<std::endl;
		return 0;
	}
	//if already visited
	if (triangle_number[current_face]>0){
		std::cout<<"=== Already visited "<<std::endl;
		return 0;
	}

	//otherwise number current triangle
	triangle_number[current_face]=triangle_nr;
	triangle_nr++;

	std::cout<<"=== numbering "<< mesh_face_number[current_face]<< " "<< triangle_number[current_face]<< std::endl;
	//visit the two other adjacent faces
	MyMesh::HalfedgeHandle he_1, he_2;
	he_1=mesh.next_halfedge_handle(current_he);
	he_2=mesh.next_halfedge_handle(he_1);
	he_number[current_he]=1;
	he_number[he_1]=2;
	he_number[he_2]=3;
	number_little_triangles(mesh, mesh.opposite_halfedge_handle(he_1), triangle_nr);
	number_little_triangles(mesh, mesh.opposite_halfedge_handle(he_2), triangle_nr);

	return 0;

}

//returns true if the mesh has a face with the 3 vertices of vhandles
/*bool has_face(MyMesh & mesh, std::vector<MyMesh::VertexHandle> vhandles){
	MyMesh::VertexHandle vstart;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		for (MyMesh::FaceVertexIter v = mesh.fv_iter(*fit); v.is_valid(); ++v ){
			for (auto vh: vhandles){
				if (*v==vhandles){
					vstart=*v;
					break;
				}
			}
		}
	}
}*/




//for each current face we need its previous face for proper orientation of neighbors
int color_next_neighbors_facet(MyMesh & mesh, std::vector<MyMesh::FaceHandle> current_faces, std::vector<MyMesh::FaceHandle> prev_faces, std::vector<int> facet_numbers){
	//static int ftype=2;
	int ftype_current;
	int facet_number;

	if (current_faces.size()==0){
		return 0;
	}

	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	bool all_neighbors_colored, newly_colored;
	int new_colors;
	std::vector<MyMesh::FaceHandle> next_faces, next_prev_faces;
    MyMesh::FaceHandle current_face, prev_face, neighbor_face;
    MyMesh::HalfedgeHandle hedge;
    std::vector<int> next_facet_numbers;


    new_colors=0;
    for (int nn=0; nn<=1; nn++){
    	newly_colored=false;
		for (int i=0; i<current_faces.size(); i++){

			current_face = current_faces[i];
			prev_face = prev_faces[i];
			facet_number=facet_numbers[i];

			//place hedge to the common edge between current_face and prev_face
			hedge = mesh.halfedge_handle(current_face);
			for (int j=0; j<3; j++){
				if (mesh.face_handle( mesh.opposite_halfedge_handle(hedge) )==prev_face){
					//std::cout<<"FOUND COMMON EDGE"<<std::endl;
					break;
				}
				hedge=mesh.next_halfedge_handle(hedge);

			}  	

	
			for (int j=0; j<=nn; j++){
				hedge=mesh.next_halfedge_handle(hedge);	
			}


			neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
			if(face_props_stripped[ neighbor_face ] ==-1 ){
				face_props_stripped[ neighbor_face ]=facet_number;
				next_faces.push_back(neighbor_face);	
				next_prev_faces.push_back(current_face);
				next_facet_numbers.push_back(facet_number);
				newly_colored=true;	

			}

    	}

    	if (newly_colored){
			new_colors++;	
		}	

	/*		for (int j=0; j<=1; j++){

				neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
				if(face_props_stripped[ neighbor_face ] ==-1 ){
					face_props_stripped[ neighbor_face ]=ftype+j; 
					next_faces.push_back(neighbor_face);	
					next_prev_faces.push_back(current_face);	

				}

				hedge=mesh.next_halfedge_handle(hedge);	
		   				
			}	
	*/	

	}
	//dump_vtk_snapshot(mesh, "/home/btyukodi/testdatafolder/specific_coloring/_rec_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");


	if (next_faces.size()==0){
		return 0;
	}	

	std::cout<<"next_faces.size() "<<next_faces.size()<<std::endl;
	//ftype+=new_colors;
	color_next_neighbors_facet(mesh, next_faces, next_prev_faces, next_facet_numbers);
	


	return 0;
}





int color_facets(MyMesh & mesh){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");

	auto set_type =  OpenMesh::FProp<int>(mesh, "set_type");
	auto pentamer_flag=  OpenMesh::FProp<int>(mesh, "is_pentamer");
	std::vector<int> facet_numbers;

	//make it Sigl specific first
	color_faces_Sigl_specific(mesh);

	color_vertices_by_faces(mesh);

	color_edges_by_vertices_and_faces(mesh);

	//Now capsid is Sigl specific
	//need to find the center triangles. Assuming the capsid is CK colored, these are the ones with the largest face types.
	int ftype_max=0;	
	int ftype;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		set_type[*fit]=0;
		ftype=face_props_stripped[*fit];
		if (ftype>ftype_max){
			ftype_max=ftype;
		}
	}

	


   	std::vector <MyMesh::VertexHandle> pentamer_vertices;
   	std::vector <MyMesh::FaceHandle> center_faces, current_faces, next_faces, prev_faces;
   	MyMesh::FaceHandle nextface;

   	center_faces=get_faces_by_type(mesh, ftype_max);
   	std::cout<<"center faces "<<center_faces.size()<<" ftypemax "<<ftype_max<<" n_faces "<<mesh.n_faces()<<std::endl;




	//if a triangle is in the center
	if (center_faces.size()==20){
		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				face_props_stripped[*fit]=-1;
				pentamer_flag[*fit]=0;
		}


		for (int i=0; i<center_faces.size(); i++){
				face_props_stripped[ center_faces[i] ]= i;
		}
		
	 		

		//std::vector <MyMesh::FaceHandle> pentamer_faces_subset = { pentamer_faces.begin(), pentamer_faces.begin()+5};

		//don't color anything for T1
		if (mesh.n_faces()>20){	
			for (auto f0: center_faces ){

		 		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(f0); fh.is_valid(); ++fh){
		  				//if next one is not pentamer
		  				nextface=mesh.face_handle(  mesh.opposite_halfedge_handle(*fh ) ) ;
		  				
		  				current_faces.push_back(nextface);

		  				prev_faces.push_back(f0);
		  				face_props_stripped[nextface]=face_props_stripped[f0];
		  				facet_numbers.push_back( face_props_stripped[f0] );
		  				
		  			
		  		}

			}
		}
	}



	int nt;
	std::vector<MyMesh::VertexHandle> hex_vertices;
	MyMesh::VertexHandle v0;
	//if a hexamer is in the center
	if (center_faces.size()==60){
		//fint the center vertices of the hexamers
		for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
			if (mesh.valence(*v)==6){
				nt=0;
				for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
					if (face_props_stripped[*vf_it]==ftype_max ){
						nt++;
					}
				}

				if (nt==3){
					hex_vertices.push_back(*v);
				}
			}
		}


		//now we have the center vertices of the center hexamers
		   	std::cout<<"hex_vertices "<<hex_vertices.size()<<" ftypemax "<<ftype_max<<std::endl;

		for (int i=0; i<hex_vertices.size(); i++){
			v0 = hex_vertices[i];
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(v0); vf_it.is_valid(); ++vf_it){

				if (face_props_stripped[*vf_it]==ftype_max){
					prev_faces.push_back(*vf_it);
					facet_numbers.push_back(i);
				}
				else{
					current_faces.push_back(*vf_it);
				}
				face_props_stripped[*vf_it]=i;
				set_type[*vf_it]=1;
				
			}
		}

		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if (set_type[*fit]==0){
				face_props_stripped[*fit]=-1;
			}

		}

	}




	//don't color anything for T1
	if (mesh.n_faces()>20){
		color_next_neighbors_facet(mesh, current_faces, prev_faces, facet_numbers);
	}
	dump_vtk_snapshot(mesh, "/home/btyukodi/meshcolorcapsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_dat_snapshot(mesh, "/home/btyukodi/vertices.dat",  "/home/btyukodi/faces.dat", "/home/btyukodi/edges.dat");	

	//now it's all colored in face_type. But we need it in facet_face_type and also set back to Sigl specific
	auto facet_face_type =  OpenMesh::FProp<int>(mesh, "facet_face_type");
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		facet_face_type[*fit] = face_props_stripped[*fit];
	}


	//make it Sigl specific again. Daichi specific needs Sigl specific first
	color_faces_Sigl_specific(mesh);
	color_vertices_by_faces(mesh);
	color_edges_by_vertices_and_faces(mesh);

	//dump_vtk_snapshot(mesh, "/home/btyukodi/back_to_sigl_meshcolorcapsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	return 0;  	   	

}


int color_facets(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	

	color_facets(mesh);


	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);


	system(("mkdir -p "+outfile_base).c_str()); 

	dump_vtk_snapshot(mesh, outfile_base  +"capsid_facet_colored_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");


	return 0;
}



//will only work with (0, n) or (m, 0) capsids. Chiral ones are more involved
//here I simply start from a pentamer and walk in the direction of one of its outgoing halfedges until I hit another pentamer
//then turn 60 degrees until I hit the second one, then 60 degrees to come back to the first and close the loop
//to be decided in what exact form to return these facets
//It appears that return value is never used 

std::tuple<std::map<int, MyMesh::VertexHandle>,  std::map<MyMesh::VertexHandle, MyMesh::VertexHandle>  >  get_icosahedron_facets(MyMesh & mesh, MyMesh & facet_mesh, std::map<int, int> orientation ){

//	auto facet_face_type =  OpenMesh::FProp<int>(mesh, "facet_face_type");
//	auto facet_edge_type = OpenMesh::HProp<int>(mesh, "facet_edge_type");	

	//auxiliary type. Face number assigned later
	auto facet_face_type =  OpenMesh::FProp<int>(mesh, "facet_face_type");
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		facet_face_type[*fit]=-1;
	}	

	auto facet_edge_type = OpenMesh::HProp<int>(mesh, "facet_edge_type");	
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		facet_edge_type[*hit]=-1;
    }  



	int facet_type=1;
	int ii;

	//first find all pentamers
	std::vector<MyMesh::VertexHandle> pentamer_vertices, vhandles;
	MyMesh::VertexHandle next_vertex, prev_vertex, tmp_vertex;
	MyMesh::HalfedgeHandle he;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find all 5-folds
		if( mesh.valence(*v)==5 ){
			pentamer_vertices.push_back(*v);
		}
	}


	//for now just do one pentamer; to be seen how to merge results from all pentamers, there will be duplicates
	MyMesh::VertexHandle p0;

		//vhandles.push_back(prototypes_mesh.add_vertex(MyMesh::Point(0,0,0)));
		//vhandles.push_back(prototypes_mesh.add_vertex(MyMesh::Point(0,1,0)));
		//vhandles.push_back(prototypes_mesh.add_vertex(MyMesh::Point(1,0,0)));	
		//proto_face = prototypes_mesh.add_face(vhandles);

	//MyMesh facet_mesh;	
	//auxiliary type. Face number assigned later in facet_face_number
	auto facet_mesh_face_type =  OpenMesh::FProp<int>(facet_mesh, "facet_face_type");
	MyMesh::FaceHandle facet_mesh_face;
	MyMesh::VertexHandle facet_vertex;
	//maps pentamer vertices of the coarse icosahedron to the vertices of the original icosahedron
	std::map<MyMesh::VertexHandle, MyMesh::VertexHandle>  vertex_map, rev_vertex_map;

	//maps facet face type to the base vertex of that type on the coarse icosahedron
	std::map<int, MyMesh::VertexHandle> base_vertex;
	for (auto p0: pentamer_vertices){
		facet_vertex = facet_mesh.add_vertex( mesh.point(p0) );
		vertex_map.insert({facet_vertex, p0});
		rev_vertex_map.insert({p0, facet_vertex});
	}


	color_facets(mesh);


/*for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it != mesh.faces_end(); ++f_it){

	std::cout<<"facet_face_type "<<facet_face_type[*f_it]<<std::endl;
}*/


/************ works with Greg icosahedra	
	std::cout<<"--here ---"<< pentamer_vertices.size() <<std::endl;
	for (int fftype=0; fftype<20; fftype++){
		vhandles.clear();
		for (auto p0:pentamer_vertices){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(p0); vf_it.is_valid(); ++vf_it){
				//if p0 belongs to current facet
				if (facet_face_type[*vf_it]==fftype){
					vhandles.push_back(rev_vertex_map[p0]);
					break;
				}
			}
		}
		std::cout<<"--here2 ---"<<vhandles.size()<<"    ";
		std::cout<<vhandles[0]<<" "<<vhandles[1]<<" "<<vhandles[2];
		std::cout<<std::endl;

		facet_mesh_face = facet_mesh.add_face(vhandles);	

		if (!facet_mesh.is_valid_handle(facet_mesh_face)){
				std::reverse(vhandles.begin(),vhandles.end()); 
				facet_mesh_face = facet_mesh.add_face(vhandles);	
				std::cout<<vhandles[0]<<" "<<vhandles[1]<<" "<<vhandles[2];
				std::cout<<std::endl;

		}
		if (facet_mesh.is_valid_handle(facet_mesh_face)){
				facet_mesh_face_type[facet_mesh_face]=fftype;
		}


	}
*******************/

	std::cout<<"--here ---"<< pentamer_vertices.size() <<std::endl;
	MyMesh::EdgeHandle ev01, ev12, ev20;
	while (facet_mesh.n_faces()<20){   //skip adding hanging faces, keep trying; a little brute force but seems it works
		for (int fftype=0; fftype<20; fftype++){
			vhandles.clear();
			for (auto p0:pentamer_vertices){
				for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(p0); vf_it.is_valid(); ++vf_it){
					//if p0 belongs to current facet
					if (facet_face_type[*vf_it]==fftype){
						vhandles.push_back(rev_vertex_map[p0]);
						break;
					}
				}
			}
			std::cout<<"--here2 ---"<<vhandles.size()<<"    "<<facet_mesh.n_faces();
			//std::cout<<vhandles[0]<<" "<<vhandles[1]<<" "<<vhandles[2];
			std::cout<<std::endl;

			//there should already exist at least one edge between any two of vhandles[], otherwise cant't specify orientation
			ev01=find_edge(facet_mesh, vhandles[0], vhandles[1]);
			ev12=find_edge(facet_mesh, vhandles[1], vhandles[2]);
			ev20=find_edge(facet_mesh, vhandles[2], vhandles[0]);

			if ( (!facet_mesh.is_valid_handle(ev01)) && (!facet_mesh.is_valid_handle(ev12)) && (!facet_mesh.is_valid_handle(ev20)) && facet_mesh.n_faces()>0 ){
				continue;
			}

			facet_mesh_face = facet_mesh.add_face(vhandles);	

			if (!facet_mesh.is_valid_handle(facet_mesh_face)){
					std::reverse(vhandles.begin(),vhandles.end()); 
					facet_mesh_face = facet_mesh.add_face(vhandles);	
					std::cout<<vhandles[0]<<" "<<vhandles[1]<<" "<<vhandles[2];
					std::cout<<std::endl;

			}
			if (facet_mesh.is_valid_handle(facet_mesh_face)){
					facet_mesh_face_type[facet_mesh_face]=fftype;
			}


		}
	}


/*	for (auto p0: pentamer_vertices){
	//p0=pentamer_vertices[0];

		for (MyMesh::VertexOHalfedgeIter h_it = mesh.voh_iter(p0); h_it.is_valid(); ++h_it){
				//if already visited/colored
				std::cout<<"facet edge type "<< facet_edge_type[*h_it] <<std::endl;
				if (facet_edge_type[*h_it]!=-1){
					//std::cout<<"HALT "<<std::endl;
					continue;
				}

				vhandles.clear();
				//!!!!vhandles.push_back( find_nearest_vertex(facet_mesh, mesh.point(p0)) );
				vhandles.push_back( rev_vertex_map[p0]);

				prev_vertex=p0;
				next_vertex = mesh.to_vertex_handle(*h_it);
				//do until next pentameric vertex is hit
				while(true){		
					//if back to starting pentamer
					if (next_vertex==p0){
						break;
					}	
					if (mesh.valence(next_vertex)==5){
						//turn 60 degrees (should happen twice per triangle)
						ii=1;
						//vhandles.push_back(facet_mesh.add_vertex( mesh.point(next_vertex)));
						//!!!!vhandles.push_back( find_nearest_vertex(facet_mesh, mesh.point(next_vertex)) );
						vhandles.push_back( rev_vertex_map[next_vertex] );

					}
					else{
						//go straight
						ii=3;
					}

					he = mesh.find_halfedge(prev_vertex, next_vertex);

					if (facet_face_type[mesh.face_handle( he ) ]==-1){

						facet_face_type[mesh.face_handle( he ) ] = facet_type;
					}

					if (facet_edge_type[he]==-1){
							facet_edge_type[he] = facet_type;
					}

					tmp_vertex=next_vertex;
					next_vertex=get_neighbor_vertices_in_order(mesh, prev_vertex, next_vertex)[ii];
					prev_vertex=tmp_vertex;

					//record vertex and halfedges
				}
			//should only add if not there already!!!	
			

			facet_mesh_face = facet_mesh.add_face(vhandles);	

			if (mesh.is_valid_handle(facet_mesh_face)){
				facet_mesh_face_type[facet_mesh_face]=facet_type;
				facet_type++;
			}
		}
	}
	//so far only triangles/halfedges at the edges of each facets are marked. We could color the rest recursively but it's probably easier to just color 
	//them by their neighbors until there is no uncolored left.
	bool any_uncolored=true;
	while(any_uncolored){
		any_uncolored=false;
		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if(facet_face_type[*fit]==-1){
				any_uncolored=true;
				break;
			}
		}

		if (!any_uncolored){
			break;
		}
		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			for(MyMesh::FaceFaceIter it1 = mesh.ff_iter(*fit); it1.is_valid(); ++it1){
				if (facet_face_type[*it1]==-1){
					facet_face_type[*it1]=facet_face_type[*fit];
				}
			} 		
		}

	}

*/

	/*dump_vtk_snapshot(mesh, "/home/btyukodi/testdatafolder/facet_detection_test/00vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_vtk_snapshot(facet_mesh, "/home/btyukodi/testdatafolder/facet_detection_test/facet_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh, "/home/btyukodi/testdatafolder/facet_detection_test/00lammps.dat");
	*/
	dump_vtk_snapshot(facet_mesh, "/home/btyukodi/facet_mesh_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	print_mesh_stripped(facet_mesh);

	std::cout<<"facet_type "<<facet_type<<std::endl;


	//face number for Daichi's layout: 5-9-13-17-21 for upper sawtooth triangles
	// 1-3-4-7-8-11-12-15-16-19 for middle strip
	//2-6-10-14-18 for lower sawtooth triangles
	//there is no 20 because it does not fit into the counting scheme
	auto facet_mesh_face_number =  OpenMesh::FProp<int>(facet_mesh, "face_number");
	MyMesh::HalfedgeHandle right_he, right_he_opp, left_he, left_he_opp;
	MyMesh::FaceHandle left_face, right_face;
	//start from any face
	int fi=1;
	MyMesh::FaceHandle current_face=facet_mesh.face_handle(0);
	facet_mesh_face_number[current_face]=fi;
	he=facet_mesh.halfedge_handle(current_face);
	base_vertex[fi]=facet_mesh.from_vertex_handle(he);

	int ix=1;
	while (ix<=10){	
		

		fi+=1;
		right_he = facet_mesh.next_halfedge_handle(he);
		right_he_opp = facet_mesh.opposite_halfedge_handle(right_he);
		right_face = facet_mesh.face_handle(right_he_opp);
		if (fi!=20){
			facet_mesh_face_number[right_face]=fi;
			if (ix%2!=0){ //upward pointing triangle
				base_vertex[fi]=facet_mesh.opposite_he_opposite_vh(right_he);
			}
			else{
				base_vertex[fi]=facet_mesh.to_vertex_handle(right_he);
			}
		}

		fi+=1;
		left_he = facet_mesh.next_halfedge_handle(right_he);
		left_he_opp = facet_mesh.opposite_halfedge_handle(left_he);
		left_face = facet_mesh.face_handle(left_he_opp);	
		if (fi!=20){	
			facet_mesh_face_number[left_face]=fi;
			if (ix%2==0){ //down pointing triangle
				base_vertex[fi]=facet_mesh.opposite_he_opposite_vh(left_he);
			}
			else{
				base_vertex[fi]=facet_mesh.from_vertex_handle(left_he);
			}
		}
		

		if (ix%2!=0){
			current_face=left_face;
			he=left_he_opp;
		}
		else{
			current_face=right_face;
			he=right_he_opp;
		}
		ix+=1;
	}


	auto mesh_face_number =  OpenMesh::FProp<int>(mesh, "face_number");
	int facet_number;
	//loop over facets of the coarse icosahedron. Those facets have both face_type and face_number. 
	//Get the matching face_type triangles from the original mesh and assign them the correct face_number
	for (MyMesh::FaceIter f_it = facet_mesh.faces_sbegin(); f_it != facet_mesh.faces_end(); ++f_it){
		facet_type=facet_mesh_face_type[*f_it];
		facet_number=facet_mesh_face_number[*f_it];
		for (MyMesh::FaceIter it = mesh.faces_sbegin(); it!=mesh.faces_end(); ++it){
			if (facet_face_type[*it]==facet_type){
				mesh_face_number[*it]=facet_number;
			}
		}

	}

	for (MyMesh::FaceIter fit = facet_mesh.faces_sbegin(); fit!=facet_mesh.faces_end(); ++fit){
		std::cout<<"----- "<<facet_mesh_face_type[*fit]<<" "<<facet_mesh_face_number[*fit]<<" "<<std::endl;
	}	


	for (MyMesh::VertexIter v = facet_mesh.vertices_sbegin(); v!=facet_mesh.vertices_end(); ++v){
		std::cout<<"***** "<< v<<" "<<vertex_map[*v]<<std::endl;

	}



	for (MyMesh::FaceIter f_it = facet_mesh.faces_sbegin(); f_it != facet_mesh.faces_end(); ++f_it){
		std::cout<<"facet"<< *f_it<<" facet_face_number "<<facet_mesh_face_number[*f_it];
		for (MyMesh::FaceVertexIter v = facet_mesh.fv_iter(*f_it); v.is_valid(); ++v ){
			std::cout<<" "<<*v;
			if (base_vertex[facet_mesh_face_number[*f_it]]==*v){
				std::cout<<"-";
			}
		}
		std::cout<<std::endl; 	
	}


	//Now also number the little triangles to mark equivalent positions w.r.t. base_vertex in the developed surface
	//!!! ---------- base_vertex should here be updated based on the orientations
	MyMesh::VertexHandle vh;
	for (MyMesh::FaceIter f_it = facet_mesh.faces_sbegin(); f_it != facet_mesh.faces_end(); ++f_it){
		fi=facet_mesh_face_number[*f_it];
		vh=base_vertex[ fi ];
		for (MyMesh::FaceHalfedgeIter fh_it = facet_mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			if(facet_mesh.from_vertex_handle(*fh_it)==vh){
				he = *fh_it;
				break;
			}
		}
		for (int ii=0; ii<orientation[fi]; ii++){
			he=facet_mesh.next_halfedge_handle(he);
		}
		base_vertex[fi]=facet_mesh.from_vertex_handle(he);
	}	

	auto triangle_number =  OpenMesh::FProp<int>(mesh, "triangle_number");	
	auto he_number = 	OpenMesh::HProp<int>(mesh, "halfedge_number");
	int triangle_nr=-1;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		triangle_number[*fit]=-1;
	}	
	MyMesh::VertexHandle bv;
	MyMesh::FaceHandle fv;
	for (fi=1; fi<=21; fi++){
		if (fi==20){
			continue;
		}

		bv= vertex_map[ base_vertex[fi] ];
		//find the outgoing halfedge which belongs to the tip triangle
		for (MyMesh::VertexOHalfedgeIter h_it = mesh.voh_iter(bv); h_it.is_valid(); ++h_it){
			fv = mesh.face_handle(*h_it);
			if (mesh_face_number[fv]==fi){
				he = *h_it;
				std::cout<<"HE FOUND "<<std::endl;
				break;
			}
		}
		he_number[he]=1;
		he=mesh.next_halfedge_handle(he);
		he_number[he]=2;
		he_number[mesh.next_halfedge_handle(he)]=3;
		he=mesh.opposite_halfedge_handle(he);

		triangle_nr=1;
		triangle_number[fv]=triangle_nr;
		triangle_nr++;
		number_little_triangles(mesh, he, triangle_nr);

	}




	//need to return (keep somehow): mesh (with its face_number property); facet_mesh(with its face_number property); 
	// base_vertex for knowing facet orientations; vertex_map for matching the coarse grained and the original mesh

	//Now facets of the 20-face icosahedron are numbered according to the flat-developed scheme
	//We now need to set facet_mesh_face_type to these numbers (on the 20-face mesh) and facet_face_type as well on the original mesh
	//The developed surface numbering will then be stored in facet_mesh_face_type on the 20-face mesh and facet_face_type on the original mesh
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		std::cout<<"++++  "<<triangle_number[*fit]<<" "<<mesh_face_number[*fit]<<" "<<std::endl;
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*fit); fh_it.is_valid(); ++fh_it){	
			std::cout<<" "<<he_number[*fh_it];
		}
		std::cout<<std::endl;
	}	


	return std::make_tuple(base_vertex, vertex_map );
}

//this actually already makes the required specificities. Should be renamed to "make_capsid_daichi_specific(om_filename, specificity_filename)"
//in daichi_design_file: 1st column: 1 2 ... 21: face number
//2nd column daichi_type: 1 2 ... ; first types are CK, then the full specific ones
//3rd column: full_specific: 0 if CK, 1 if full specific
//4th column: orientation. Should only matter for full specific
//Needs a properly colored CK capsid as input!!
int make_capsid_daichi_specific(std::string om_filename, std::string daichi_design_file, std::string outfile_base){
	std::cout<<"Making Daichi specific"<<std::endl;
	std::cout<<om_filename<<std::endl;
	std::cout<<daichi_design_file<<std::endl;
	std::cout<<outfile_base<<std::endl;		

	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh, facet_mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	//retrieve base_vertex and vertex_map here; rename function to assign_Daichi_design
   	//Daichi's design should be given by two maps:
   	//1. full_specificity[fi]=0/1/2/3... depending on which face to make full specific and what kind of full specific
   	//2. orientation[fi]=0/1/2 w.r.t base.
   	// start with CK specifics then keep the ntypes to that point and ++ for full specific
   	// do all same-kind full specifics at once - how to iterate over those facets? Do we need to number little triangles first? Or can we just color through the iteration?

	auto mesh_face_number =  OpenMesh::FProp<int>(mesh, "face_number"); //to which coarse facet the triangle belongs to
	auto triangle_number =  OpenMesh::FProp<int>(mesh, "triangle_number");	//place of the triangle within one facet relative to the base vertex; The base vertex is set by the orientation given in Daichi's scheme
	auto he_number = 	OpenMesh::HProp<int>(mesh, "halfedge_number");      //halfedge number within the triangle

   	std::map<int, int> orientation, daichi_type, full_specific;
   	//e.g. 332
   	std::ifstream design_file(daichi_design_file);
   	int tmp, fi;
	while (!design_file.eof()){		
		design_file >> fi;
		design_file >> tmp;
		daichi_type[fi]=tmp;

		design_file >> tmp;
		full_specific[fi]=tmp;

		design_file >> tmp;
		orientation[fi]=tmp;				
	}
	design_file.close();

/*********  332 	
	for (int fi=1; fi<=21; fi++){
   		orientation[fi]=0;
   		daichi_type[fi]=3;
   		full_specific[fi]=1;
   	}

   	//blue
   	daichi_type[1]=1;
   	daichi_type[7]=1;
   	daichi_type[14]=1;
   	daichi_type[17]=1;   

	full_specific[1]=0;
	full_specific[7]=0;
	full_specific[14]=0;
	full_specific[17]=0;  

   	//green
   	daichi_type[5]=2;
   	daichi_type[6]=2;
   	daichi_type[11]=2;
   	daichi_type[16]=2;   

   	full_specific[5]=0;
   	full_specific[6]=0;
   	full_specific[11]=0;
   	full_specific[16]=0;     		



   	orientation[3]=1;
   	orientation[4]=1;   
   	orientation[13]=1;
   	orientation[18]=1;   	


   	orientation[8]=2;
   	orientation[10]=2;   
   	orientation[19]=2;
   	orientation[21]=2;     
************************/


   	get_icosahedron_facets(mesh, facet_mesh, orientation);




   	int ck_face_type_increment=0;
   	int ck_edge_type_increment=0;
   	int T=mesh.n_faces()/20;

   	std::vector<int> etypes;
   	std::vector<int> ftypes;
   	int ne_types, nf_types;
 	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
 		ftypes.push_back(face_props_stripped[*fit]);
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*fit); fh_it.is_valid(); ++fh_it){	
			etypes.push_back(edge_props_stripped[*fh_it]);
		}
	}   
	nf_types=std::set<int>( ftypes.begin(), ftypes.end() ).size();
	ne_types=std::set<int>( etypes.begin(), etypes.end() ).size();	
	std::cout<<"T="<<T<<" ne_types="<<ne_types<< " nf_types="<<nf_types<<std::endl;	

   	for (int fi=1; fi<=21; fi++){
   		if (fi==20){
   			continue;
   		}
   		if (full_specific[fi]==0){
		 	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		 		if (mesh_face_number[*fit]==fi){
			 		face_props_stripped[*fit]+=(daichi_type[fi]-1)*nf_types;
					for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*fit); fh_it.is_valid(); ++fh_it){	
						edge_props_stripped[*fh_it]+=(daichi_type[fi]-1)*ne_types;

					}
				}
			}
			//ck_face_type_increment++;
			//ck_edge_type_increment++;	  			
   		}
   	}

    //------- now need to color the full specific ones
    //first re-compute the current number of edge and face types. Will start from here for the specific ones

    int full_spec_face_type_increment=0;
   	int full_spec_edge_type_increment=0;

    etypes.clear();
    ftypes.clear();
 	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
 		ftypes.push_back(face_props_stripped[*fit]);
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*fit); fh_it.is_valid(); ++fh_it){	
			etypes.push_back(edge_props_stripped[*fh_it]);
		}
	}   
	int nf_types_ck=std::set<int>( ftypes.begin(), ftypes.end() ).size();
	int ne_types_ck=std::set<int>( etypes.begin(), etypes.end() ).size();
	int n_ck;//=2;//!!! GET AUTOMATICALLY!!! Also, if n_ck=0, then set nf_types=0 and ne_types=0 manually, otherwise it will assume the initial CK coloring
	std::vector<int> ck_types;
   	for (int fi=1; fi<=21; fi++){
   		if (fi==20){
   			continue;
   		}
   		if (full_specific[fi]==0){
   			ck_types.push_back( daichi_type[fi] );
   		}
   	}
   	n_ck=std::set<int>( ck_types.begin(), ck_types.end() ).size();
   	std::cout<<daichi_design_file<<" NCK "<<n_ck<<std::endl;
   	if (n_ck==0){
   		nf_types_ck=0;
   		ne_types_ck=0;
   	}


	std::cout<<"^^^ "<<nf_types_ck<<" "<<ne_types_ck<<" "<<n_ck<<std::endl;
   	for (int fi=1; fi<=21; fi++){
   		if (fi==20){
   			continue;
   		}
   		if (full_specific[fi]==1){
		 	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){

		 		if (mesh_face_number[*fit]==fi){
		 			face_props_stripped[*fit]=nf_types_ck-1+(daichi_type[fi]-n_ck-1)*T+triangle_number[*fit]; //<--- not OK for more than 1 full specific type
		 			
			 		
					for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*fit); fh_it.is_valid(); ++fh_it){	
						edge_props_stripped[*fh_it]=ne_types_ck-1+ (daichi_type[fi]-n_ck-1)*3*T+(triangle_number[*fit]-1)*3+he_number[*fh_it];//<--- not OK

					}
				}
			}
			//ck_face_type_increment++;
			//ck_edge_type_increment++;	  			
   		}
   	}


   	int ntypes_final=0;
   	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
   		if (face_props_stripped[*fit]>ntypes_final){
   			ntypes_final=face_props_stripped[*fit];
   		}
   	}

    //also need some better Ovito coloring scheme that keeps into account that some triangles may have single edge type; it would make things more readable

   	omfile.close();

   	//create a type_map.conf file. For each subunit_type we map the corresponding daichi type of the coarse icosahedron.
   	//This then can be used to color based on both subunit type and daichi type to make snapshots more readable.
   	//Will go through all subunits and there might be duplicate rows.
    //A given subunt type should only correspond to a single daichi type
    system(("mkdir -p "+outfile_base).c_str());
    std::map<int, int> mapconf;

    for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
    	mapconf.insert({face_props_stripped[*fit], daichi_type[mesh_face_number[*fit]] });
    }


    std::ofstream mapconf_file( outfile_base+"type_map.conf" );
	for (auto const& p : mapconf)
	{
	    mapconf_file << p.first << " " << p.second << std::endl;
	}

    /*for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
    	mapconf_file<<face_props_stripped[*fit]<<" "<< daichi_type[mesh_face_number[*fit]] <<std::endl;
    }*/
    mapconf_file.close();

    //generate the corresponding vtk_colors.conf file
    //read colors from daichi_facet_colors.conf: daichi_facet_type | R | G | B
	std::ifstream daichi_facet_colors("/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/init_structures/Daichi_design/daichi_facet_colors_new.conf");
	std::vector<double> red, green, blue;
	std::vector<int> daichi_facet_type_conf;
	double tmpr;
	while (!daichi_facet_colors.eof()){	

		daichi_facet_colors >> tmpr;
		red.push_back(tmpr);
		daichi_facet_colors >> tmpr;
		green.push_back(tmpr);
		daichi_facet_colors >>tmpr;
		blue.push_back(tmpr);
		daichi_facet_colors >>tmpr;
		daichi_facet_type_conf.push_back(tmpr);
	}

	daichi_facet_colors.close();    

	//generate the vtk_colors.conf file
	//first, simply color by daichi_type. Then we'll shade it
	std::ofstream vtk_custom_file(outfile_base+"vtk_colors_custom.conf" );

	vtk_custom_file.precision(6);	
	vtk_custom_file.setf(std::ios::fixed);
	vtk_custom_file.setf(std::ios::showpoint);

	int subunit_type, daichi_facet_type;
	double subunit_alpha=1.0;

    std::map<int, int> type_count; //how many types are there in a given daichi_facet_type. Needed for alpha shading   
	for (auto const& p : mapconf)
	{
	    subunit_type = p.first; //assumed to iterate in order
	    daichi_facet_type =  p.second -1; //0, 1, 2, ..., 19
	    type_count.insert({daichi_facet_type, 0});
	    
	}

	for (auto const& p : mapconf)
	{
	    subunit_type = p.first; //assumed to iterate in order
	    daichi_facet_type =  p.second -1; //0, 1, 2, ..., 19
	    type_count[daichi_facet_type]++;
	}	


	int ic;
	for (auto const& p : mapconf)
	{
	    subunit_type = p.first; //assumed to iterate in order
	    daichi_facet_type =  p.second -1; //0, 1, 2, ..., 19


	    //find the colors for the corresponding daichi_facet_type. Use first and drop it from color arrays
	    
	    for (ic=0; ic<daichi_facet_type_conf.size(); ic++){
	    	if (daichi_facet_type_conf[ic]==daichi_facet_type){
	    		break;
	    	}
	    }


		//subunit_alpha=alpha_count[daichi_facet_type];
		subunit_alpha=1.0;

	    vtk_custom_file<< red[ic]<<" "<< blue[ic]<<" "<<green[ic] << " "<< 1.0<<std::endl;
	    //drop the color to prevent it from being used again
	    red.erase(red.begin() + ic);
	    green.erase(green.begin() + ic);
	    blue.erase(blue.begin() + ic);
	    daichi_facet_type_conf.erase(daichi_facet_type_conf.begin() + ic);




	}

	vtk_custom_file.close();



	//find facet boundary edges for marking them
	MyMesh::HalfedgeHandle h1, h2;
	MyMesh::FaceHandle f1, f2;
	std::vector<int> facet_boundary_edge_types;
	std::ofstream facet_boundary_edge_types_file(outfile_base+"facet_boundary_edge_types.dat" );
	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		h1 = mesh.halfedge_handle(*e_it, 0);
		h2 = mesh.halfedge_handle(*e_it, 1);
		f1 = mesh.face_handle(h1);
		f2 = mesh.face_handle(h2);

		if( mesh_face_number[f1]!=mesh_face_number[f2] ){
			facet_boundary_edge_types.push_back(edge_props_stripped[h1]);
			facet_boundary_edge_types.push_back(edge_props_stripped[h2]);			
		}
	}

	std::sort( facet_boundary_edge_types.begin(), facet_boundary_edge_types.end() );
	facet_boundary_edge_types.erase( std::unique( facet_boundary_edge_types.begin(), facet_boundary_edge_types.end() ), facet_boundary_edge_types.end() );

	for (auto et: facet_boundary_edge_types){
		facet_boundary_edge_types_file<<et<<std::endl;
	}	


	facet_boundary_edge_types_file.close();


   	//std::string outfile_base="/home/btyukodi/testdatafolder/facet_detection_test/Daichi_specific/";
   	system(("mkdir -p "+outfile_base  +"datfiles_daichi_specific").c_str());
	//dump_vtk_snapshot(mesh, outfile_base  + "capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_vtk_snapshot(mesh, outfile_base  + "capsid_vtk.dat", outfile_base+"vtk_colors_custom.conf");

	dump_lammps_snapshot_double_edge(mesh, outfile_base  +  "capsid_double_edge_lammps.dat"); 
	dump_lammps_typed_edges_snapshot(mesh, outfile_base  +  "capsid_lammps.dat");  	  	
	dump_dat_snapshot(mesh, outfile_base  + "datfiles_daichi_specific/vertices.dat", outfile_base  + "datfiles_daichi_specific/faces.dat", outfile_base  + "datfiles_daichi_specific/edges.dat");

	print_capsid_data(mesh, outfile_base);
    std::ofstream edge_bonds( outfile_base+"edge_bonds.dat" );
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_bonds<<edge_props_stripped[*hit]<<" "<<edge_props_stripped[mesh.opposite_halfedge_handle(*hit)]<<std::endl;
    }      	
    edge_bonds.close();


    //save the full capsid in .om for later seed generations
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
	std::ofstream output_full_om(outfile_base+"full_capsid.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_full_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_full_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_full_om.close();	


	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

/*
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
*/

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_init_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	


	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << timestep;
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, outfile_om_single_seed, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	//dump_om(mesh, timestep, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	




	//read the full capsid files and leave one subunit. If I knew how to copy meshes properly, I Wouldn't need to read it from disk
	std::ifstream full_capsid_om;	
	std::ofstream s_om;
	system(("mkdir -p "+outfile_base+"/single_subunit_seeds/").c_str()); 


	for (int fix=0; fix<20*T; fix++){
		full_capsid_om.open(outfile_base +"full_capsid.om", std::ios::out | std::ios::binary); 
		full_capsid_om >> timestep;
		OpenMesh::IO::read_mesh(mesh, full_capsid_om, _ext, ropt);
		full_capsid_om.close();

		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				if ( (*fit).idx()!=fix){
					mesh.delete_face(*fit);
				}

		}
		mesh.garbage_collection();



		s_om.open(outfile_base + "/single_subunit_seeds/s"+std::to_string(fix)+".om", std::ios::out | std::ios::binary);
		timestep=0;
		s_om << timestep;
		try
		  {
		    if ( !OpenMesh::IO::write_mesh(mesh, s_om, ".OM") )
		    {
		      std::cerr << "Cannot write mesh to stream" << std::endl;
		      return 0;
		    }
		  }
		  catch( std::exception& x )
		  {
		    std::cerr << "EXCEPTION" << x.what() << std::endl;
		    return 0;
		  }	
		s_om.close();


	}


	//print stats; number of face types, cross bindings, etc.
	int ncross = get_number_of_cross_bindings(mesh, -1, true);
	std::cout<<outfile_base<<std::endl;
	std::cout<<"Daichistat  ncross:"<<ncross<<" ntypes:"<<ntypes_final<<std::endl;

   	return 0;

}



//for each current face we need its previous face for proper orientation of neighbors
//to be used when merging Caspar Klug coloring.
int color_next_neighbors_merge(MyMesh & mesh, std::vector<MyMesh::FaceHandle> current_faces, std::vector<MyMesh::FaceHandle> prev_faces, int ftype, std::vector<int> & merge_pattern){
	//static int ftype=2;

	int merge_rule = merge_pattern[0];
	merge_pattern.erase(merge_pattern.begin());
	int ftype_current;

	if (current_faces.size()==0){
		return 0;
	}

	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	bool all_neighbors_colored, newly_colored;
	int new_colors;
	std::vector<MyMesh::FaceHandle> next_faces, next_prev_faces;
    MyMesh::FaceHandle current_face, prev_face, neighbor_face;
    MyMesh::HalfedgeHandle hedge;



    new_colors=0;
    for (int nn=0; nn<=1; nn++){
    	newly_colored=false;
		for (int i=0; i<current_faces.size(); i++){

			current_face = current_faces[i];
			prev_face = prev_faces[i];

			//place hedge to the common edge between current_face and prev_face
			hedge = mesh.halfedge_handle(current_face);
			for (int j=0; j<3; j++){
				if (mesh.face_handle( mesh.opposite_halfedge_handle(hedge) )==prev_face){
					//std::cout<<"FOUND COMMON EDGE"<<std::endl;
					break;
				}
				hedge=mesh.next_halfedge_handle(hedge);

			}  	

	
			for (int j=0; j<=nn; j++){
				hedge=mesh.next_halfedge_handle(hedge);	
			}


			neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
			if(face_props_stripped[ neighbor_face ] ==-1 ){
				if (merge_rule==3 & nn==0){
					face_props_stripped[ neighbor_face ]=ftype-1;//+nn; 
				}
				else if (merge_rule==2 & nn==1){
					face_props_stripped[ neighbor_face ]=ftype-1;//+nn; 

				}
				else if (merge_rule==4){
					face_props_stripped[ neighbor_face ]=ftype-1;//+nn; 					
				}
				else if (merge_rule==1){
					face_props_stripped[ neighbor_face ]=ftype+ new_colors;
					newly_colored=true;	
				}
				else{
					face_props_stripped[ neighbor_face ]=ftype+ new_colors;//+nn; 
					newly_colored=true;	
				}
				next_faces.push_back(neighbor_face);	
				next_prev_faces.push_back(current_face);
				

			}

    	}

    	if (newly_colored){
    		//if (merge_rule==1 & nn==1)
    		if (merge_rule!=1){
				new_colors++;	
			}
			else if (nn==1){
				new_colors++;
			}
			else{
				new_colors++;
			}
		}	

	/*		for (int j=0; j<=1; j++){

				neighbor_face = mesh.face_handle(mesh.opposite_halfedge_handle(hedge) );
				if(face_props_stripped[ neighbor_face ] ==-1 ){
					face_props_stripped[ neighbor_face ]=ftype+j; 
					next_faces.push_back(neighbor_face);	
					next_prev_faces.push_back(current_face);	

				}

				hedge=mesh.next_halfedge_handle(hedge);	
		   				
			}	
	*/	

	}
	dump_vtk_snapshot(mesh, "/home/btyukodi/testdatafolder/specific_coloring_merge/"+std::to_string(ftype)+"_rec_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");


	if (next_faces.size()==0){
		return 0;
	}	

	std::cout<<"next_faces.size() "<<next_faces.size()<<std::endl;
	//ftype+=new_colors;

	color_next_neighbors_merge(mesh, next_faces, next_prev_faces, ftype+new_colors, merge_pattern);
	


	return 0;
}

 //+std::to_string(fix)+".om"
//will need to handle first 2 separately
int color_faces_Sigl_specific_merge(MyMesh & mesh, std::vector<int> & merge_pattern){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");

	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			face_props_stripped[*fit]=-1;
	}

  	int ftype=0;	


   	std::vector <MyMesh::VertexHandle> pentamer_vertices;
   	std::vector <MyMesh::FaceHandle> pentamer_faces, current_faces, next_faces, prev_faces;
   	MyMesh::FaceHandle nextface;

	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
		    for (MyMesh::VertexFaceIter vf = mesh.vf_iter(*v); vf.is_valid(); ++vf ){
		        pentamer_faces.push_back(*vf);
		    	face_props_stripped[ *vf ] = ftype;
		    }  
		}
	}  		

	ftype++;
	for (auto f0: pentamer_faces ){
 		for (MyMesh::FaceHalfedgeIter fh = mesh.fh_iter(f0); fh.is_valid(); ++fh){
  				//if next one is not pentamer
  				nextface=mesh.face_handle(  mesh.opposite_halfedge_handle(*fh ) ) ;
  				if ( face_props_stripped[ nextface ]!=0 ){
  					current_faces.push_back(nextface);
  					prev_faces.push_back(f0);
  					face_props_stripped[nextface]=ftype;
  				}
  			
  		}

	}


	color_next_neighbors_merge(mesh, current_faces, prev_faces, 2, merge_pattern);


	return 0;  	   	

}

int make_capsid_Sigl_specific_merge(std::string om_filename, std::string outfile_base, std::vector<int> & merge_pattern){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	

	color_faces_Sigl_specific_merge(mesh, merge_pattern);

	color_vertices_by_faces(mesh);

	color_edges_by_vertices_and_faces(mesh);

	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	system(("mkdir -p "+outfile_base  +"datfiles_Sigl_specific").c_str());	
	std::ofstream output_om(outfile_base+"Sigl_specific.om", std::ios::out | std::ios::binary);	
	//write the timestep first, then the mesh 	
		
	output_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	


  	output_om.close();	



	dump_vtk_snapshot(mesh, outfile_base  +"capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_double_edge_lammps.dat");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_lammps.dat");



	dump_dat_snapshot(mesh, outfile_base  + "datfiles_merged_specific/vertices.dat", outfile_base  + "datfiles_Sigl_specific/faces.dat", outfile_base  + "datfiles_Sigl_specific/edges.dat");


	//dump dihedrals and edge lengths
	print_capsid_data(mesh, outfile_base);

	//std::cout<<outfile_base<<std::endl;
	print_mesh_stripped(mesh);


	//create single subunit and pentamer seeds
	//find a pentamer vertex
	MyMesh::VertexHandle vpentamer;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if ( mesh.valence(*v)==5 ){
			vpentamer=(*v);
			break;
		}
	}


	auto to_remove =  OpenMesh::FProp<int>(mesh, "to_remove");	
    for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
    	to_remove[*fit]=1;
    }

	//mark its neighboring faces

	for (MyMesh::VertexFaceIter vf = mesh.vf_iter(vpentamer); vf.is_valid(); ++vf ){
		to_remove[*vf]=0;
	}

	//std::vector<MyMesh::FaceHandle> rmlist;
	//bool more_deleted=true;
	//while (more_deleted){
	//	more_deleted=false;
	    for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
	    	if(to_remove[*fit]==1){
	    		mesh.delete_face(*fit);
	  //  		more_deleted=true;
	    		//std::cout<<"DELETED "<<mesh.n_faces()<<std::endl;
	  //  		break;
	    		//rmlist.push_back(*fit);
	    	}
	    }
	//}
    /*for (auto f: rmlist){
    	mesh.delete_face(f);
    }*/

    mesh.garbage_collection();

    long long t=0;

	std::ofstream outfile_om_pentamer_seed(outfile_base+"pentamer_seed.om", std::ios::out | std::ios::binary);
	outfile_om_pentamer_seed << t;
	dump_om(mesh, 0, outfile_om_pentamer_seed);
	outfile_om_pentamer_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");

	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << t;
	dump_om(mesh, 0, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	

return 0;

}




//recursive function to generate all rotations. Original CK types are rotated together.
int rotate(int ftype_ck, MyMesh mesh, std::vector<MyMesh> & configurations){
	std::vector<MyMesh::FaceHandle> faces;
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	
	int etype1, etype2, etype3, etype_tmp;
	MyMesh::HalfedgeHandle he, he1, he2, he3;
	MyMesh mesh2;

	if (ftype_ck<0){
		configurations.push_back(mesh);
		//std::cout<<"mesh "<<&mesh<<std::endl;
		return 0;
	}

	for (int nrot=0; nrot<=2; nrot++){
		//rotate all faces of original type ftype_ck by one
		faces = get_faces_by_ck_type(mesh, ftype_ck); 
		for (auto r: faces){
			he1 = mesh.halfedge_handle(r);
			he2 = mesh.next_halfedge_handle(he1);
			he3 = mesh.next_halfedge_handle(he2);

			etype_tmp = edge_props_stripped[he1];
			edge_props_stripped[he1] = edge_props_stripped[he3];
			edge_props_stripped[he3] = edge_props_stripped[he2];
			edge_props_stripped[he2] = etype_tmp;
		}

		rotate(ftype_ck-1, mesh, configurations);
	}

	return 0;

}


//take a mesh, merge two faces according to merge_rule
//eg. merge_rule=[2,3] will transform all (originally) type 3 faces to type 2 faces. 

int merge_faces(MyMesh & mesh, std::vector<int> merge_rule){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");	
	auto edge_props_ck = OpenMesh::HProp<int>(mesh, "edge_type_ck");		
	int donor_type = merge_rule[0];
	int recipient_type = merge_rule[1];


	//faces which originally were of type recipient_type will be recolored
	//original CK coloring is still kept
	std::vector<MyMesh::FaceHandle> recipient_faces = get_faces_by_ck_type(mesh, recipient_type);



	MyMesh::FaceHandle recipient_face = recipient_faces[0];
	//if performance is an issue, here finding a single donor face (not all) should be sufficient.
	std::vector<MyMesh::FaceHandle> donor_faces = get_faces_by_ck_type(mesh, donor_type);	
	MyMesh::FaceHandle donor_face = donor_faces[0];
	std::vector<int> donor_edge_types;
	int recipient_base_edge_type, etype1, etype2, etype3, etype_tmp;

	MyMesh::HalfedgeHandle he, he1, he2, he3;
	//find donor edge types in some order
	he= mesh.halfedge_handle(donor_face);
	for (int j=0; j<=2; j++){
		donor_edge_types.push_back( edge_props_ck[he] );
		he = mesh.next_halfedge_handle(he);
	}

	he= mesh.halfedge_handle(recipient_face);
	recipient_base_edge_type = edge_props_stripped[he]; 
	//find recipient edge types in some order 
/*	he= mesh.halfedge_handle(recipient_face);
	for (int j=0; j<=2; j++){
		recipient_edge_types.push_back( edge_props_stripped[he] );
		he = mesh.next_halfedge_handle(he);
	}	
*/
	//set all recipient edge types, properly oriented
	for (auto r: recipient_faces){
		//pin orientation
		he = mesh.halfedge_handle(r);
		for (int j=0; j<=2; j++){
			he = mesh.next_halfedge_handle(he);
			if (edge_props_stripped[he]==recipient_base_edge_type){
				break;
			}
		}

		for (int j=0; j<=2; j++){
			edge_props_stripped[he] = donor_edge_types[j];
			he = mesh.next_halfedge_handle(he);
		}		
	}	




	//now all recipient edge types are set to donor by one orientation. Recipient face types are still the original types.

/*************	no need to rotate here any more. They'll be rotated recursively together	
	//need to rotate until the minimum cross binding orientation is found
	std::vector<int> n_cross_bindings;
	for (int rot=0; rot<=2; rot++){
		n_cross_bindings.push_back( get_number_of_cross_bindings(mesh, donor_type) );
		//rotate each face of type recipient type once
		for (auto r: recipient_faces){
			he1 = mesh.halfedge_handle(r);
			he2 = mesh.next_halfedge_handle(he1);
			he3 = mesh.next_halfedge_handle(he2);

			etype_tmp = edge_props_stripped[he1];
			edge_props_stripped[he1] = edge_props_stripped[he3];
			edge_props_stripped[he3] = edge_props_stripped[he2];
			edge_props_stripped[he2] = etype_tmp;
		}
	}



	int nrot = std::min_element(n_cross_bindings.begin(), n_cross_bindings.end()) - n_cross_bindings.begin(); 

	std::cout<<"nrot "<<nrot<<std::endl;
	std::cout<<"n_cross ";
	for (int rot=0; rot<=2; rot++){
		std::cout<<" "<<n_cross_bindings[rot];
	}
	std::cout<<std::endl;

	for (int rot=0; rot<nrot; rot++){
		for (auto r: recipient_faces){
			he1 = mesh.halfedge_handle(r);
			he2 = mesh.next_halfedge_handle(he1);
			he3 = mesh.next_halfedge_handle(he2);

			etype_tmp = edge_props_stripped[he1];
			edge_props_stripped[he1] = edge_props_stripped[he3];
			edge_props_stripped[he3] = edge_props_stripped[he2];
			edge_props_stripped[he2] = etype_tmp;
		}
	}	
**************/

	//recolor all recipients and save their original types
	for (auto r: recipient_faces){
		face_props_stripped[r]=donor_type;

	}

	//std::cout<<"All cross bindings: "<<get_number_of_cross_bindings(mesh, -1, true)<<std::endl;

	return 0;
}


//should be a simple function to merge edge types. Might not be necessary
//at the end of face merges we should only have a single face type with at most 3 edge types
//should be straightforward to handle
//unless we want to combine edge merges with face merges
/*int merge_edges(){

}*/




//Rewritten to do single step merges as follows
//merge pattern tells which CK faces will be colored the same
//faces are recolored in a single step, then original types rotated together to minimize cross bindings
//CK face types will be completely lost. It is irrelevant if a face was a type X, all that matters is which faces are of the same type in the end
//upon recoloring (merging) it is assumed that all faces have 3 edge types. In CK there may be center faces with a single edge type.
//If a newly colored species has only such subunits that used to be single-edge type in CK, then those edge types should be reconsidered (TBD-probably not crucial)
int make_capsid_merged_specific(std::string om_filename, std::string outfile_base, std::vector<std::vector<int> > merge_pattern){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto face_props_ck =  OpenMesh::FProp<int>(mesh, "face_type_ck");	
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
	auto edge_props_ck = OpenMesh::HProp<int>(mesh, "edge_type_ck");	
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);		

   	//save original CK types
   	int ck_types=0;

   	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
   		face_props_ck[*fit] = face_props_stripped[*fit];
   		if (face_props_ck[*fit]>ck_types){
   			ck_types=face_props_ck[*fit];
   		}
   	}
	for (MyMesh::HalfedgeIter h_it = mesh.halfedges_sbegin();h_it != mesh.halfedges_end(); ++h_it ){
		edge_props_ck[*h_it] = edge_props_stripped[*h_it];
	}


   	std::cout<<"merge started"<<std::endl;

   	int ftype_new=0;
   	std::vector<int> merge_rule;
   	for (int i=0; i<merge_pattern.size(); i++){
   		//should save each iteration for debugging
   		//merge_faces(mesh, merge_pattern[i]);
   		for (auto j: merge_pattern[i]){
   			std::cout<<"ftype_new"<<ftype_new<<"  j "<<j<<std::endl;
   			merge_rule.clear();
   			merge_rule.push_back(ftype_new);
   			merge_rule.push_back(j);
   			merge_faces(mesh, merge_rule);
   		}
   		ftype_new++;
   	}

   	std::cout<<"merge done"<<std::endl;
   	//Should check if there are any subunit species whose all instances are in a 3-fold symmetry environment (i.e. surrounded by the same edge type)
   	//If so, the species edge types should be set the same to reduce cross binding. This is not important from simulations but important for the counting of cross-bindings

   	std::vector<MyMesh::FaceHandle> faces;
   	MyMesh::HalfedgeHandle he1, he2, he3, he;
   	int etype1, etype2, etype3, etype_base;
   	bool symmetric;
   	for (int ftype=0; ftype<ftype_new; ftype++){
   		faces = get_faces_by_type(mesh, ftype);
   		symmetric=true;
   		for (auto face: faces){
   			he1 = mesh.halfedge_handle(face);
   			etype_base = edge_props_stripped[he1];
   			he2 = mesh.next_halfedge_handle(he1);
   			he3 = mesh.next_halfedge_handle(he2);

   			he1=mesh.opposite_halfedge_handle(he1);
   			he2=mesh.opposite_halfedge_handle(he2);
   			he3=mesh.opposite_halfedge_handle(he3);

   			etype1=edge_props_stripped[he1];
   			etype2=edge_props_stripped[he2];
   			etype3=edge_props_stripped[he3];
   			if (etype1==etype2 & etype2==etype3){
   				//if symmetric, do nothing
   			}
   			else{
   				//if found any instances not symmetric
   				symmetric=false;
   			}
   		}
   		if (symmetric){
			for (auto face: faces){
				for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(face); fh_it.is_valid(); ++fh_it){	
					//etype base is set every time in the previous for loop. But only the last one (in fact, any one) matters.
					//any edge of the subunit will do.
					edge_props_stripped[*fh_it]=etype_base;	
				}
			}
   		}

   	}

   	//HERE SHOULD RELABEL FACE TYPES TO MAKE THEM CONTIGUOUS
   	//absolutely no effort made here to make this efficient
   	std::vector<int> all_types;
   
   	int ftypemax, etypemax; //largest type until contiguous
   	int df, de;
   	bool shifted=true;

   	while(shifted){
   		shifted=false;
	   	all_types.clear();
		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			all_types.push_back(face_props_stripped[*fit]);
		}

		std::sort( all_types.begin(), all_types.end() );
		all_types.erase( std::unique( all_types.begin(), all_types.end() ), all_types.end() );
		//now all_types[] is a unique, sorted array of types
		ftypemax=0;
		for (int i=0; i<all_types.size(); i++){
			if (all_types[i]==i){
				ftypemax++;
			}
			else{
				df = all_types[i]-i;
				shifted=true;
				break;
			}
		}




		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if (face_props_stripped[*fit]>ftypemax){
				face_props_stripped[*fit]-=df;
			}
		}
	}

	//also need to relabel the edge types to keep them contiguous
	shifted=true;
   	while(shifted){
   		shifted=false;
	   	all_types.clear();
		for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
			all_types.push_back(edge_props_stripped[*hit]);
		}

		std::sort( all_types.begin(), all_types.end() );
		all_types.erase( std::unique( all_types.begin(), all_types.end() ), all_types.end() );
		//now all_types[] is a unique, sorted array of types
		etypemax=0;
		for (int i=0; i<all_types.size(); i++){
			if (all_types[i]==i){
				etypemax++;
			}
			else{
				de = all_types[i]-i;
				shifted=true;
				std::cout<<"eshift"<<std::endl;
				break;
			}
		}

		for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
			if (edge_props_stripped[*hit]>etypemax){
				edge_props_stripped[*hit]-=de;
			}
		}
	}



   	//now it's all consistently recolored, but still need to find the orientation with minimal cross-binding
   	std::vector<MyMesh> configurations;
   	std::cout<<"rotating... "<<std::endl;
   	rotate(ck_types, mesh, configurations);
   	std::cout<<"CONF "<<configurations.size()<<" ftypemax "<<ftypemax-1<<" "<<"CK types "<<ck_types<<std::endl;
   	int n_cross_min=get_number_of_cross_bindings(configurations[0],-1, true);
   	int n_cross;
   	mesh = configurations[0];

   	int ci=0;
   	for (auto c: configurations){
		//dump_vtk_snapshot(c, outfile_base +"/rotations/"+std::to_string(ci)+"capsid_vtk.vtk", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
		//dump_lammps_snapshot_double_edge(c,  outfile_base +"/rotations/"+std::to_string(ci) +"capsid_double_edge_lammps.dat");
		ci++;

   		//std::cout<<"ncross "<<get_number_of_cross_bindings(c,-1, true)<<std::endl;
   		n_cross = get_number_of_cross_bindings(c,-1, true);
   		if (n_cross < n_cross_min){
   			n_cross_min=n_cross;
   			mesh=c;
   		}

   	}



/*	std::cout<<std::endl<<" xx ";
	for (int i=0; i<all_types.size(); i++){
		std::cout<<" "<<all_types[i];
	}
*/

	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	system(("mkdir -p "+outfile_base  +"datfiles_merged_specific").c_str());	
	std::ofstream output_om(outfile_base+"merged_specific.om", std::ios::out | std::ios::binary);	
	//write the timestep first, then the mesh 	
		
	output_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	


  	output_om.close();	

  	std::string merge_pattern_str="";
  	for (auto merge_rule: merge_pattern){
   		//should save each iteration for debugging
   		for (auto ftype: merge_rule){
   			merge_pattern_str+=std::to_string(ftype)+"_";
   		}
   		merge_pattern_str+="|";
   	}


	std::cout<<"ncross "<<" "<<merge_pattern_str<<"\t"<<n_cross_min<<std::endl;
	system(("mkdir -p "+outfile_base  +"datfiles_merged_specific").c_str());

	dump_vtk_snapshot(mesh, outfile_base  +merge_pattern_str+"capsid_vtk.vtk", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base +merge_pattern_str +"capsid_double_edge_lammps.dat");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base +merge_pattern_str +"capsid_lammps.dat");

	dump_dat_snapshot(mesh, outfile_base  + "datfiles_merged_specific/vertices.dat", outfile_base  + "datfiles_merged_specific/faces.dat", outfile_base  + "datfiles_merged_specific/edges.dat");


//save full_capsid.om here, create single subunit seeds

	//dump dihedrals and edge lengths
	print_capsid_data(mesh, outfile_base);


	print_mesh_stripped(mesh);



	/*****************all sort of seed dumps*************************************/


	   std::ofstream edge_bonds( outfile_base+"edge_bonds.dat" );
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_bonds<<edge_props_stripped[*hit]<<" "<<edge_props_stripped[mesh.opposite_halfedge_handle(*hit)]<<std::endl;
    }      	
    edge_bonds.close();


    //save the full capsid in .om for later seed generations
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
	std::ofstream output_full_om(outfile_base+"full_capsid.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_full_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_full_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_full_om.close();	
	int T=mesh.n_faces()/20;

	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

/*
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
*/

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_init_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	


	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << timestep;
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, outfile_om_single_seed, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	//dump_om(mesh, timestep, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	




	//read the full capsid files and leave one subunit. If I knew how to copy meshes properly, I Wouldn't need to read it from disk
	std::ifstream full_capsid_om;	
	std::ofstream s_om;
	system(("mkdir -p "+outfile_base+"/single_subunit_seeds/").c_str()); 


	for (int fix=0; fix<20*T; fix++){
		full_capsid_om.open(outfile_base +"full_capsid.om", std::ios::out | std::ios::binary); 
		full_capsid_om >> timestep;
		OpenMesh::IO::read_mesh(mesh, full_capsid_om, _ext, ropt);
		full_capsid_om.close();

		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				if ( (*fit).idx()!=fix){
					mesh.delete_face(*fit);
				}

		}
		mesh.garbage_collection();



		s_om.open(outfile_base + "/single_subunit_seeds/s"+std::to_string(fix)+".om", std::ios::out | std::ios::binary);
		timestep=0;
		s_om << timestep;
		try
		  {
		    if ( !OpenMesh::IO::write_mesh(mesh, s_om, ".OM") )
		    {
		      std::cerr << "Cannot write mesh to stream" << std::endl;
		      return 0;
		    }
		  }
		  catch( std::exception& x )
		  {
		    std::cerr << "EXCEPTION" << x.what() << std::endl;
		    return 0;
		  }	
		s_om.close();


	}
	/*******************************************************************/

	return n_cross;
}



/*To be used for single species simple seeds and other init files to integrate with Daichi and sub-CK specific workflows*/
int create_simple_seeds(std::string om_filename, std::string outfile_base){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	


   	system(("mkdir -p "+outfile_base  +"datfiles_merged_specific").c_str());
	dump_vtk_snapshot(mesh, outfile_base  + "capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh, outfile_base  +  "capsid_double_edge_lammps.dat");   	
	dump_dat_snapshot(mesh, outfile_base  + "datfiles_merged_specific/vertices.dat", outfile_base  + "datfiles_merged_specific/faces.dat", outfile_base  + "datfiles_merged_specific/edges.dat");

	print_capsid_data(mesh, outfile_base);
		/*****************all sort of seed dumps*************************************/
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	std::ofstream edge_bonds( outfile_base+"edge_bonds.dat" );
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_bonds<<edge_props_stripped[*hit]<<" "<<edge_props_stripped[mesh.opposite_halfedge_handle(*hit)]<<std::endl;
    }      	
    edge_bonds.close();


    //save the full capsid in .om for later seed generations
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
	std::ofstream output_full_om(outfile_base+"full_capsid.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_full_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_full_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_full_om.close();	
	int T=mesh.n_faces()/20;



	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

/*
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
*/

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_init_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	


	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << timestep;
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, outfile_om_single_seed, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	//dump_om(mesh, timestep, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	




	//read the full capsid files and leave one subunit. If I knew how to copy meshes properly, I Wouldn't need to read it from disk
	std::ifstream full_capsid_om;	
	std::ofstream s_om;
	system(("mkdir -p "+outfile_base+"/single_subunit_seeds/").c_str()); 


	int nfaces=20*T;
	for (int fix=0; fix<nfaces; fix++){
		full_capsid_om.open(outfile_base +"full_capsid.om", std::ios::out | std::ios::binary); 
		full_capsid_om >> timestep;
		OpenMesh::IO::read_mesh(mesh, full_capsid_om, _ext, ropt);
		full_capsid_om.close();

		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				if ( (*fit).idx()!=fix){
					mesh.delete_face(*fit);
				}

		}
		mesh.garbage_collection();



		s_om.open(outfile_base + "/single_subunit_seeds/s"+std::to_string(fix)+".om", std::ios::out | std::ios::binary);
		timestep=0;
		s_om << timestep;
		try
		  {
		    if ( !OpenMesh::IO::write_mesh(mesh, s_om, ".OM") )
		    {
		      std::cerr << "Cannot write mesh to stream" << std::endl;
		      return 0;
		    }
		  }
		  catch( std::exception& x )
		  {
		    std::cerr << "EXCEPTION" << x.what() << std::endl;
		    return 0;
		  }	
		s_om.close();


	}
	/*******************************************************************/
	return 1;
}

//from all merge patterns of k colorings, selects one with the fewest cross bindings
int make_capsid_merged_specific(std::string om_filename, std::string outfile_base, int n_ck_colors, int k){

	//to a tmp directory, generate all merges, find the least cross binding
	std::vector<std::vector<std::vector<int> > > all_patterns;
	all_patterns = get_partitions( n_ck_colors, k); 
	int n_cross_min=9999;
	int n_cross;
	std::string tmp_dir=outfile_base+"/tmp/";
	system(("mkdir -p "+tmp_dir).c_str()); 

	std::vector<std::vector<int> > mincross_merge_pattern;
	for (auto merge_pattern: all_patterns){
		n_cross=make_capsid_merged_specific(om_filename, tmp_dir, merge_pattern);
		if (n_cross<n_cross_min){
			n_cross_min=n_cross;
			mincross_merge_pattern=merge_pattern;
		}
	}

	system(("rm -r "+tmp_dir).c_str()); 

	//regenerate the least cross binding to the final folder
	make_capsid_merged_specific(om_filename, outfile_base, mincross_merge_pattern);
	std::cout<<"MERGESTAT "<<om_filename<<"\tcolors: "<<k<<"\tcrossbonds: "<<n_cross_min<<std::endl;


	return 0;
} 


int make_capsid_merged_specific_old(std::string om_filename, std::string outfile_base, std::vector<std::vector<int> > merge_pattern){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);		



   	for (int i=0; i<merge_pattern.size(); i++){
   		//should save each iteration for debugging
   		merge_faces(mesh, merge_pattern[i]);
   	}

   	//HERE SHOULD RELABEL FACE TYPES TO MAKE THEM CONTIGUOUS
   	//absolutely no effort made here to make this efficient
   	std::vector<int> all_types;
   
   	int ftypemax, etypemax; //largest type until contiguous
   	int df, de;
   	bool shifted=true;

   	while(shifted){
   		shifted=false;
	   	all_types.clear();
		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			all_types.push_back(face_props_stripped[*fit]);
		}

		std::sort( all_types.begin(), all_types.end() );
		all_types.erase( std::unique( all_types.begin(), all_types.end() ), all_types.end() );
		//now all_types[] is a unique, sorted array of types
		ftypemax=0;
		for (int i=0; i<all_types.size(); i++){
			if (all_types[i]==i){
				ftypemax++;
			}
			else{
				df = all_types[i]-i;
				shifted=true;
				break;
			}
		}




		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
			if (face_props_stripped[*fit]>ftypemax){
				face_props_stripped[*fit]-=df;
			}
		}
	}

	//also need to relabel the edge types to keep them contiguous
	shifted=true;
   	while(shifted){
   		shifted=false;
	   	all_types.clear();
		for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
			all_types.push_back(edge_props_stripped[*hit]);
		}

		std::sort( all_types.begin(), all_types.end() );
		all_types.erase( std::unique( all_types.begin(), all_types.end() ), all_types.end() );
		//now all_types[] is a unique, sorted array of types
		etypemax=0;
		for (int i=0; i<all_types.size(); i++){
			if (all_types[i]==i){
				etypemax++;
			}
			else{
				de = all_types[i]-i;
				shifted=true;
				std::cout<<"eshift"<<std::endl;
				break;
			}
		}

		for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
			if (edge_props_stripped[*hit]>etypemax){
				edge_props_stripped[*hit]-=de;
			}
		}
	}




	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);

	system(("mkdir -p "+outfile_base  +"datfiles_merged_specific").c_str());	
	std::ofstream output_om(outfile_base+"merged_specific.om", std::ios::out | std::ios::binary);	
	//write the timestep first, then the mesh 	
		
	output_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	


  	output_om.close();	

  	std::string merge_pattern_str;
  	for (auto merge_rule: merge_pattern){
   		//should save each iteration for debugging
   		for (auto ftype: merge_rule){
   			merge_pattern_str+=std::to_string(ftype)+"_";
   		}
   		merge_pattern_str+="|";
   	}



	dump_vtk_snapshot(mesh, outfile_base  +merge_pattern_str+"capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_double_edge_lammps.dat");
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_lammps.dat");



	dump_dat_snapshot(mesh, outfile_base  + "datfiles_merged_specific/vertices.dat", outfile_base  + "datfiles_merged_specific/faces.dat", outfile_base  + "datfiles_merged_specific/edges.dat");


	//dump dihedrals and edge lengths
	print_capsid_data(mesh, outfile_base);


	print_mesh_stripped(mesh);

	return 0;
}



int copy_mesh_test(std::string om_filename){
	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep=0;
	MyMesh mesh, mesh2;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");
  	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);	


   	mesh2=mesh;

	auto face_props_stripped2 =  OpenMesh::FProp<int>(mesh2, "face_type");
	auto edge_props_stripped2 = OpenMesh::HProp<int>(mesh2, "edge_type");   	

face_props_stripped[mesh.face_handle(0)]=-99999;
	print_mesh_stripped(mesh);

	std::cout<<"===="<<std::endl;
	print_mesh_stripped(mesh2);

   	return 0;

   }


int merge_faces_old(MyMesh & mesh, std::vector<int> merge_rule){
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	int donor_type = merge_rule[0];
	int recipient_type = merge_rule[1];



	std::vector<MyMesh::FaceHandle> recipient_faces = get_faces_by_type(mesh, recipient_type);



	MyMesh::FaceHandle recipient_face = recipient_faces[0];
	//if performance is an issue, here finding a single donor face (not all) should be sufficient.
	std::vector<MyMesh::FaceHandle> donor_faces = get_faces_by_type(mesh, donor_type);	
	MyMesh::FaceHandle donor_face = donor_faces[0];
	std::vector<int> donor_edge_types;
	int recipient_base_edge_type, etype1, etype2, etype3, etype_tmp;

	MyMesh::HalfedgeHandle he, he1, he2, he3;
	//find donor edge types in some order
	he= mesh.halfedge_handle(donor_face);
	for (int j=0; j<=2; j++){
		donor_edge_types.push_back( edge_props_stripped[he] );
		he = mesh.next_halfedge_handle(he);
	}

	he= mesh.halfedge_handle(recipient_face);
	recipient_base_edge_type = edge_props_stripped[he]; 
	//find recipient edge types in some order 
/*	he= mesh.halfedge_handle(recipient_face);
	for (int j=0; j<=2; j++){
		recipient_edge_types.push_back( edge_props_stripped[he] );
		he = mesh.next_halfedge_handle(he);
	}	
*/
	//set all recipient edge types, properly oriented
	for (auto r: recipient_faces){
		//pin orientation
		he = mesh.halfedge_handle(r);
		for (int j=0; j<=2; j++){
			he = mesh.next_halfedge_handle(he);
			if (edge_props_stripped[he]==donor_edge_types[0]){
				break;
			}
		}

		for (int j=0; j<=2; j++){
			edge_props_stripped[he] = donor_edge_types[j];
			he = mesh.next_halfedge_handle(he);
		}		
	}	




	//now all recipient edge types are set to donor by one orientation. Recipient face types are still the original types.

/*************	no need to rotate here any more. They'll be rotated recursively together	
	//need to rotate until the minimum cross binding orientation is found
	std::vector<int> n_cross_bindings;
	for (int rot=0; rot<=2; rot++){
		n_cross_bindings.push_back( get_number_of_cross_bindings(mesh, donor_type) );
		//rotate each face of type recipient type once
		for (auto r: recipient_faces){
			he1 = mesh.halfedge_handle(r);
			he2 = mesh.next_halfedge_handle(he1);
			he3 = mesh.next_halfedge_handle(he2);

			etype_tmp = edge_props_stripped[he1];
			edge_props_stripped[he1] = edge_props_stripped[he3];
			edge_props_stripped[he3] = edge_props_stripped[he2];
			edge_props_stripped[he2] = etype_tmp;
		}
	}



	int nrot = std::min_element(n_cross_bindings.begin(), n_cross_bindings.end()) - n_cross_bindings.begin(); 

	std::cout<<"nrot "<<nrot<<std::endl;
	std::cout<<"n_cross ";
	for (int rot=0; rot<=2; rot++){
		std::cout<<" "<<n_cross_bindings[rot];
	}
	std::cout<<std::endl;

	for (int rot=0; rot<nrot; rot++){
		for (auto r: recipient_faces){
			he1 = mesh.halfedge_handle(r);
			he2 = mesh.next_halfedge_handle(he1);
			he3 = mesh.next_halfedge_handle(he2);

			etype_tmp = edge_props_stripped[he1];
			edge_props_stripped[he1] = edge_props_stripped[he3];
			edge_props_stripped[he3] = edge_props_stripped[he2];
			edge_props_stripped[he2] = etype_tmp;
		}
	}	
**************/

	//recolor all recipients and save their original types
	for (auto r: recipient_faces){
		face_props_stripped[r]=donor_type;

	}

	//std::cout<<"All cross bindings: "<<get_number_of_cross_bindings(mesh, -1, true)<<std::endl;

	return 0;
}



//computes local mean and gaussian curvatures associated to vertices
//Discrete Differential-Geometry Operators for Triangulated 2-Manifolds Mark Meyer1, Mathieu Desbrun1,2, Peter Schroder1, and Alan H. Barr
//http://www.geometry.caltech.edu/pubs/DMSB_III.pdf
//http://rodolphe-vaillant.fr/entry/20/compute-harmonic-weights-on-a-triangular-mesh#cell_area
void compute_curvature(MyMesh & mesh, MyMesh::VertexHandle v0){

	//store it as vertex property
	auto mean_curvature_prop=OpenMesh::VProp<double>(mesh, "mean_curvature");
	auto gaussian_curvature_prop=OpenMesh::VProp<double>(mesh, "gaussian_curvature");	

	MyMesh::HalfedgeHandle he1, he2, he3;
	MyMesh::VertexHandle v1, v2;
	double A_mixed=0.0;
	double a_voronoi, a_triangle;
	double H;
	MyMesh::Point dp = MyMesh::Point(0,0,0); 
	MyMesh::Point p01, p12, p20, e01, e12, e20, e3, e2;
	double theta0, theta1, theta2, cos0, cos1, cos2, cot1, cot2, cot_alpha_ij, cot_beta_ij;
	//loop around vertice's outgoing halfedges
	for (MyMesh::VertexOHalfedgeIter h_it = mesh.voh_iter(v0); h_it.is_valid(); ++h_it){
		he1=(*h_it);
		he2=mesh.next_halfedge_handle(he1);
		he3=mesh.next_halfedge_handle(he2);
		v1=mesh.to_vertex_handle(he1);
		v2=mesh.to_vertex_handle(he2);

		//compute angles, check if any is obtuse
		p01 = mesh.point(v1) - mesh.point(v0);
		p12 = mesh.point(v2) - mesh.point(v1);
		p20 = mesh.point(v0) - mesh.point(v2);

		e01=p01.normalize();
		e20=p20.normalize();
		e12=p12.normalize();



		cos0 =  e01.dot(-e20); 
		cos1 =  (-e01).dot(e12);
		cos2 =  e20.dot( -e12 );

		cot1= cos1 / (e01 % e12).norm() ;  
		cot2= cos2 / (e12 % e20).norm() ;  
		//if triangle is not obtuse
		if ( (cos0>=0) && (cos1>=0) && (cos2>=0) ){
			a_voronoi=(1.0/8.0)*(p01.sqrnorm()*cot1  + p20.sqrnorm()*cot2);
			A_mixed+=a_voronoi;
		}
		else{
			//from vector product %
			a_triangle= (p01 % p20).norm() * 0.5;
			if (cos0<0){
				A_mixed+=a_triangle/2.0;
			}
			else{
				A_mixed+=a_triangle/4.0;
			}
		}


		cot_alpha_ij = cot2;

		//now move to adjacent triangle to find beta_ij
		he1 = mesh.opposite_halfedge_handle(he1);
		he2 = mesh.next_halfedge_handle(he1);
		he3 = mesh.next_halfedge_handle(he2);

		e2 = (mesh.point(mesh.to_vertex_handle(he2)) - mesh.point(mesh.from_vertex_handle(he2))  ).normalize();
		e3 = (mesh.point(mesh.to_vertex_handle(he3)) - mesh.point(mesh.from_vertex_handle(he3))  ).normalize();

		cot_beta_ij = (-e2).dot(e3) / (e2 % e3).norm();

		dp+= (cot_alpha_ij + cot_beta_ij)*p01;
	}

	dp/=(2.0*A_mixed);

	H=dp.norm()/2.0;
	std::cout<<H<<"\t"<<1.0/H<<std::endl;
	mean_curvature_prop[v0]=H;
}



void compute_curvature(MyMesh & mesh){
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		compute_curvature(mesh, *v);
	}
}


void compute_curvature(std::string om_filename, std::string outfile_path){
    std::ofstream mean_curvature_os;		   	  	

	mean_curvature_os.precision(6);	
	mean_curvature_os.setf(std::ios::fixed);
	mean_curvature_os.setf(std::ios::showpoint);	
		

	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
 	//alernatingly read a timestep (long) and a mesh (.om) objects
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh_stripped;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh_stripped, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh_stripped, "edge_type");	
	auto mean_curvature_prop=OpenMesh::VProp<double>(mesh_stripped, "mean_curvature");

	while (omfile >> timestep){

   		
   		OpenMesh::IO::read_mesh(mesh_stripped, omfile, _ext, ropt);

		compute_curvature(mesh_stripped);
		mean_curvature_os.open( outfile_path+"mean_curvature_"+std::to_string(timestep)+".dat" );   

		for (MyMesh::VertexIter v = mesh_stripped.vertices_sbegin(); v!=mesh_stripped.vertices_end(); ++v){
			mean_curvature_os<<(*v).idx()+1<<" "<<mean_curvature_prop[*v]<<std::endl;
		}
		mean_curvature_os.close();
	}
	omfile.close();

}


//count the number of possible discination spots. Not the actual number of ways to form those (yet). Needs an input json (for the interaction matrix) with an inital file with the full capsid
//these are generated with generate_dummy_jsons(df) from stage_runs.py
void count_disclination_spots(std::string input_file){
	MyMesh mesh;	
	//add parameters to init_mesh; if init_config provided, init_from_om too
    RunParameters rp;	
    read_set_run_params(rp, input_file);   

	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();
	init_mesh_from_om(mesh, rp.init_file, rp.init_file_pos, input_file);
	auto edge_props = OpenMesh::HProp<HalfedgeProp>(mesh, "edge_props");
	std::cout<<input_file<<" "<<mesh.n_faces()<<std::endl;


	MyMesh::HalfedgeHandle he1, he2, he3, ohe1, ohe2, ohe3;
	int otype1, otype2, otype3;
	int number_of_possible_disclination_spots=0;
/*	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it != mesh.faces_end(); ++f_it){
		he1=mesh.halfedge_handle(*f_it);
		he2=mesh.next_halfedge_handle(he1);
		he3=mesh.next_halfedge_handle(he2);

		ohe1=mesh.opposite_halfedge_handle(he1);
		ohe2=mesh.opposite_halfedge_handle(he2);
		ohe3=mesh.opposite_halfedge_handle(he3);

		otype1=edge_props[ohe1].edge_type;
		otype2=edge_props[ohe2].edge_type;
		otype3=edge_props[ohe3].edge_type;				

		number_of_possible_disclinations+=(int)(edge_props[ohe1].e_b[otype2]<100) + (int)(edge_props[ohe2].e_b[otype3]<100) + (int)(edge_props[ohe3].e_b[otype1]<100);

	}
*/	
	int disclination_spot;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		disclination_spot=0;
		for (MyMesh::VertexOHalfedgeIter h_it1 = mesh.voh_iter(*v); h_it1.is_valid(); ++h_it1){
			for (MyMesh::VertexOHalfedgeIter h_it2 = mesh.voh_iter(*v); h_it2.is_valid(); ++h_it2){
				if (*h_it1==*h_it2){
					continue;
				}
				else{
					he1=*h_it1;
					ohe2=mesh.opposite_halfedge_handle(*h_it2);
					otype2=edge_props[ohe2].edge_type;
					if (edge_props[he1].e_b[otype2]<100){
						disclination_spot=1;
						break;
					}
				}


			}
			if (disclination_spot){
				break;
			}

		}
		number_of_possible_disclination_spots+=disclination_spot;
	}

	std::cout<<"disc "<<mesh.n_faces()<<" " <<input_file<<" "<<number_of_possible_disclination_spots<<std::endl;
	return;
}


//Needs a properly colored CK capsid as input!!
int make_capsid_botond_specific(std::string om_filename, std::string outfile_base){
	std::cout<<"Making Botond specific"<<std::endl;
	std::cout<<om_filename<<std::endl;
	std::cout<<outfile_base<<std::endl;	

	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	MyMesh mesh, facet_mesh;
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  		
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	omfile.close();


   	int T=mesh.n_faces()/20;

	int ftype_max=0;	
	int ftype;

	int etype_max=0;
	int etype;
	//find largest face type and count from there
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		ftype=face_props_stripped[*fit];
		if (ftype>ftype_max){
			ftype_max=ftype;
		}
	}   

	//find largest edge type and count from there
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit!=mesh.halfedges_end(); ++hit){
		etype=edge_props_stripped[*hit];
		if (etype>etype_max){
			etype_max=etype;
		}
	}   		

	int position_in_pentamer;
	MyMesh::FaceHandle face;
	MyMesh::HalfedgeHandle he;
   	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
   		position_in_pentamer=0;
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexOHalfedgeIter oh = mesh.voh_iter(*v); oh.is_valid(); ++oh ){
				if (position_in_pentamer==0){
					position_in_pentamer++;
					continue;
				}
				else{

					face = mesh.face_handle(*oh);
					face_props_stripped[face]=ftype_max+position_in_pentamer;

					edge_props_stripped[*oh]=etype_max+(2*position_in_pentamer-1);
					he = mesh.prev_halfedge_handle(*oh);

					edge_props_stripped[he]=etype_max+2*position_in_pentamer;

					position_in_pentamer++;


				}
			}
		}
	}



  	//std::string outfile_base="/home/btyukodi/testdatafolder/facet_detection_test/Daichi_specific/";
   	system(("mkdir -p "+outfile_base  +"datfiles_botond_specific").c_str());
	dump_vtk_snapshot(mesh, outfile_base  + "capsid_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");
	dump_lammps_snapshot_double_edge(mesh, outfile_base  +  "capsid_double_edge_lammps.dat");   	
	dump_dat_snapshot(mesh, outfile_base  + "datfiles_botond_specific/vertices.dat", outfile_base  + "datfiles_botond_specific/faces.dat", outfile_base  + "datfiles_botond_specific/edges.dat");

	print_capsid_data(mesh, outfile_base);
    std::ofstream edge_bonds( outfile_base+"edge_bonds.dat" );
	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		edge_bonds<<edge_props_stripped[*hit]<<" "<<edge_props_stripped[mesh.opposite_halfedge_handle(*hit)]<<std::endl;
    }      	
    edge_bonds.close();


    //save the full capsid in .om for later seed generations
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
	std::ofstream output_full_om(outfile_base+"full_capsid.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_full_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_full_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_full_om.close();	


	//also create an initial nonremovable pentamer seed
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		//find a 5-fold
		if( mesh.valence(*v)==5 ){
			for (MyMesh::VertexFaceIter vf_it=mesh.vf_iter(*v); vf_it.is_valid(); ++vf_it){
				face_props_stripped[*vf_it] = -face_props_stripped[*vf_it]-2;
			}
		break;

		}

	}
	//remove all positive faces
    mesh.request_face_status();
    mesh.request_edge_status();
    mesh.request_vertex_status();
	std::vector<MyMesh::FaceHandle> faces_to_rm;
	for (MyMesh::FaceIter fit = mesh.faces_begin(); fit!=mesh.faces_end(); ++fit){
		if (face_props_stripped[*fit]>=0){
			faces_to_rm.push_back(*fit);
			//mesh.delete_face(*fit);
		}
	}

	for (int i=0; i<faces_to_rm.size(); i++){
		mesh.delete_face(faces_to_rm[i], true);
	}


	mesh.garbage_collection();

/*
	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);
*/

	std::ofstream output_init_om(outfile_base+"pentamer_non_removable.om", std::ios::out | std::ios::binary);
	//write the timestep first, then the mesh 	
	timestep=0;		
	output_init_om<<timestep;			
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, output_init_om, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	output_init_om.close();
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"pentamer_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"pentamer_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	


	//single subunit seed
	int n_r=0;
	for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
		if (n_r<4){
			mesh.delete_face(*fit);
			n_r++;
		}

	}

    mesh.garbage_collection();

	std::ofstream outfile_om_single_seed(outfile_base+"single_subunit_seed.om", std::ios::out | std::ios::binary);
	outfile_om_single_seed << timestep;
	try
	  {
	    if ( !OpenMesh::IO::write_mesh(mesh, outfile_om_single_seed, ".OM") )
	    {
	      std::cerr << "Cannot write mesh to stream" << std::endl;
	      return 0;
	    }
	  }
	  catch( std::exception& x )
	  {
	    std::cerr << "EXCEPTION" << x.what() << std::endl;
	    return 0;
	  }	
	//dump_om(mesh, timestep, outfile_om_single_seed);
	outfile_om_single_seed.close();  
	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"single_subunit_seed_double_edge_lammps.dat");  
	dump_vtk_snapshot(mesh, outfile_base  +"single_subunit_seed_vtk.dat", "/home/btyukodi/assembly_openmesh/OpenMesh-9.0/src/OpenMesh/Apps/Assembly/vtk_colors.conf");	




	//read the full capsid files and leave one subunit. If I knew how to copy meshes properly, I Wouldn't need to read it from disk
	std::ifstream full_capsid_om;	
	std::ofstream s_om;
	system(("mkdir -p "+outfile_base+"/single_subunit_seeds/").c_str()); 


	for (int fix=0; fix<20*T; fix++){
		full_capsid_om.open(outfile_base +"full_capsid.om", std::ios::out | std::ios::binary); 
		full_capsid_om >> timestep;
		OpenMesh::IO::read_mesh(mesh, full_capsid_om, _ext, ropt);
		full_capsid_om.close();

		for (MyMesh::FaceIter fit = mesh.faces_sbegin(); fit!=mesh.faces_end(); ++fit){
				if ( (*fit).idx()!=fix){
					mesh.delete_face(*fit);
				}

		}
		mesh.garbage_collection();



		s_om.open(outfile_base + "/single_subunit_seeds/s"+std::to_string(fix)+".om", std::ios::out | std::ios::binary);
		timestep=0;
		s_om << timestep;
		try
		  {
		    if ( !OpenMesh::IO::write_mesh(mesh, s_om, ".OM") )
		    {
		      std::cerr << "Cannot write mesh to stream" << std::endl;
		      return 0;
		    }
		  }
		  catch( std::exception& x )
		  {
		    std::cerr << "EXCEPTION" << x.what() << std::endl;
		    return 0;
		  }	
		s_om.close();


	}


	//print stats; number of face types, cross bindings, etc.
	int ncross = get_number_of_cross_bindings(mesh, -1, true);
	std::cout<<outfile_base<<std::endl;
	std::cout<<"Botondstat  ncross:"<<ncross<<std::endl;


return 0;
}


double get_max_height(MyMesh & mesh){
	double zmax=-10000.0;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if (mesh.point(*v)[2] > zmax){
			zmax=mesh.point(*v)[2];
		}
	}

	double zmin=10000.0;
	for (MyMesh::VertexIter v = mesh.vertices_sbegin(); v!=mesh.vertices_end(); ++v){
		if (mesh.point(*v)[2] < zmin){
			zmin=mesh.point(*v)[2];
		}
	}

	return zmax-zmin;
}


//SAT input
//bound_edges.dat :  edge_id1   |   edge_id2
//faces_edges.dat:   dace_id    |   edge_id1   |   edge_id2   |    edge_id3

int print_mesh_SAT_input(std::string om_filename, std::string outfile_base){
	std::cout<<"Printing SAT input format "<<std::endl;
	std::cout<<om_filename<<std::endl;
	std::cout<<outfile_base<<std::endl;	

	system(("mkdir -p "+outfile_base).c_str());

	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects

	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;
	
	//auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	//auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	//auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;
  	MyMesh mesh;	
   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	omfile.close();


   	std::ofstream os_edges( outfile_base+"bound_edges.dat" );
   	std::ofstream os_faces( outfile_base+"faces_edges.dat" );   	
		   	  	



	for (MyMesh::FaceIter f_it = mesh.faces_sbegin(); f_it != mesh.faces_end(); ++f_it){
		os_faces<<(*f_it).idx()<<"\t";
		for (MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(*f_it); fh_it.is_valid(); ++fh_it){	
			os_faces<<(*fh_it).idx()<<"\t";
		}	
	os_faces<<std::endl; 
	}


	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		os_edges<<(*hit).idx()<<"\t"<< (mesh.opposite_halfedge_handle(*hit)).idx()  <<std::endl;
    }      	

os_edges.close();
os_faces.close();

return 0;
 }


int make_capsid_SAT_specific(std::string om_filename, std::string SAT_coloring_file ,std::string outfile_base){
	system(("mkdir -p "+outfile_base).c_str());

	std::ifstream omfile(om_filename, std::ios::out | std::ios::binary);
	//omfile.seekg(om_byte_position, omfile.beg); 
 	//alernatingly read a timestep (long) and a mesh (.om) objects
  	MyMesh mesh;	
	const std::string _ext=".OM";
	OpenMesh::IO::Options ropt, wopt;	
	ropt+=OpenMesh::IO::Options::FaceColor; 	
	long timestep;


   	auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");   	

	mesh.request_face_status();
  	mesh.request_edge_status();
  	mesh.request_vertex_status();    
  	mesh.request_halfedge_status();
	mesh.request_face_normals();	
	
	//auto face_props_stripped =  OpenMesh::FProp<int>(mesh, "face_type");
	//auto edge_props_stripped = OpenMesh::HProp<int>(mesh, "edge_type");		
	//auto vertex_props_stripped = OpenMesh::VProp<int>(mesh, "vertex_type");	

	omfile >> timestep;

   	OpenMesh::IO::read_mesh(mesh, omfile, _ext, ropt);

   	omfile.close();


   	map<int, int> sat_edge_types; //edge_id | edge_type
   	std::ifstream SAT_file(SAT_coloring_file);
   	int tmp1, tmp2;
   	while(!SAT_file.eof()){
   		SAT_file>>tmp1;
   		SAT_file>>tmp2;
   		sat_edge_types.insert({tmp1, tmp2});
   	}

   	SAT_file.close();

	for (MyMesh::HalfedgeIter hit = mesh.halfedges_sbegin(); hit != mesh.halfedges_end(); ++hit){
		 edge_props_stripped[*hit] = sat_edge_types[ (*hit).idx() ];
	}



	OpenMesh::FPropHandleT< int > ifprop;	
	OpenMesh::HPropHandleT< int > ihprop;
	mesh.get_property_handle(ifprop, "face_type");
	mesh.get_property_handle(ihprop, "edge_type");
	mesh.property(ifprop).set_persistent(true);
	mesh.property(ihprop).set_persistent(true);	

	system(("mkdir -p "+outfile_base ).c_str());	

	dump_lammps_snapshot_double_edge(mesh,  outfile_base  +"capsid_double_edge_lammps.dat");

	int ncross=get_number_of_cross_bindings(mesh, -1, true);

	std::cout<<"xxx "<<SAT_coloring_file<<"  ncross="<<ncross<<std::endl;

   	return 0;	
}


double compute_mean_quadratic_strain(MyMesh & mesh){
 	double l02_avg=0.0;
 	double dl2_avg=0.0;
 	double dtheta2_avg=0.0;

	auto edge_props = OpenMesh::HProp<HalfedgeProp>(mesh, "edge_props");

	MyMesh::HalfedgeHandle hedge1, hedge2; 
	int edge_type1, edge_type2;
	double theta, theta0, l, l01, l02;
	int n_l0=0;
	int n_theta=0;

	for (MyMesh::EdgeIter e_it=mesh.edges_sbegin(); e_it!=mesh.edges_end(); ++e_it){
		hedge1=mesh.halfedge_handle(*e_it, 0);
		hedge2=mesh.halfedge_handle(*e_it, 1);

		edge_type1 = edge_props[hedge1].edge_type;
		edge_type2 = edge_props[hedge2].edge_type;

		if (!mesh.is_boundary(*e_it)){

			theta0 = 0.5*(edge_props[hedge1].theta0[edge_type2] + edge_props[hedge2].theta0[edge_type1] );
			theta = mesh.calc_dihedral_angle(*e_it);
			dtheta2_avg+=(theta-theta0)*(theta-theta0);
			n_theta++;
		}


		l = mesh.calc_edge_length(*e_it);
		l01=edge_props[hedge1].l0;
		l02=edge_props[hedge2].l0;

		if (!mesh.is_boundary(hedge1)){
			l02_avg+=l01*l01;
			n_l0++;
		}

		if (!mesh.is_boundary(hedge2)){
			l02_avg+=l02*l02;
			n_l0++;

		}

	}


	if (n_theta>0){
		dtheta2_avg/=n_theta;
	}
	//no need to divide dl2 and l02 because it's a ratio already
	return dl2_avg / l02_avg + dtheta2_avg;
 }